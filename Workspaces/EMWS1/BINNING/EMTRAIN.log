MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 17, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:13:10" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                November 17, 2015
Time:                14:13:10
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O1O4F0VK "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O1O4F0VK new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 17, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:13:10" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                bteric01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70080760";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_7PRO";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M1P120413";
MPRINT(EM_DIAGRAM):   put "EM Version:          13.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 17, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:13:10" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                bteric01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
22484      proc freq data=EMWS1.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.BINNING_VariableSet noprint;
22485      table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
22486      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 6 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

22487      proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
22488      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
22489      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
22490      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
22491      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
22492      run;

NOTE: There were 6 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

22493      title10;
MPRINT(EM_DIAGRAM):   title10;
22494      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Project_4';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Diagram_1';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
22837      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
22838      * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
22839      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
22840      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

22841      %let EMEXCEPTIONSTRING=;
22842      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
22843      * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
22844      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
22845      %let EM_ACTION = TRAIN;
22846      %let syscc = 0;
22847      %macro main;
22848      
22849        filename temp catalog 'sashelp.emmdfy.binning_macros.source';
22850        %include temp;
22851        filename temp;
22852      
22853        %setProperties;
22854      
22855        %if %upcase(&EM_ACTION) = CREATE %then %do;
22856          filename temp catalog 'sashelp.emmdfy.binning_create.source';
22857          %include temp;
22858          filename temp;
22859      
22860          %create;
22861        %end;
22862      
22863         %else
22864         %if %upcase(&EM_ACTION) = TRAIN %then %do;
22865      
22866             filename temp catalog 'sashelp.emmdfy.binning_train.source';
22867             %include temp;
22868             filename temp;
22869             %train;
22870         %end;
22871      
22872        %else
22873        %if %upcase(&EM_ACTION) = SCORE %then %do;
22874          filename temp catalog 'sashelp.emmdfy.binning_score.source';
22875          %include temp;
22876          filename temp;
22877      
22878          %score;
22879      
22880        %end;
22881      
22882        %else
22883        %if %upcase(&EM_ACTION) = REPORT %then %do;
22884      
22885             filename temp catalog 'sashelp.emmdfy.binning_report.source';
22886             %include temp;
22887             filename temp;
22888      
22889             %report;
22890         %end;
22891      
22892         %doendm:
22893      %mend main;
22894      
22895      %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
22896     +
22897     +%macro SetProperties;
22898     +
22899     +     /* IGN options */
22900     +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
22901     +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
22902     +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
22903     +
22904     +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
22905     +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
22906     +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
22907     +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
22908     +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
22909     +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
22910     +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
22911     +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
22912     +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
22913     +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
22914     +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
22915     +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
22916     +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
22917     +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
22918     +
22919     +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
22920     +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
22921     +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
22922     +
22923     +
22924     +%mend SetProperties;
22925     +%macro appendfiles(fileref1, fileref2);
22926     +     data _null_;
22927     +       length c $256;
22928     +       fid1=fopen("&fileref1",'A');
22929     +       fid2=fopen("&fileref2",'I');
22930     +       cval = finfo(fid2,'lrecl');
22931     +       put cval= fid1= fid2=;
22932     +       if (fid2 > 0) then
22933     +         do while(fread(fid2)=0);
22934     +           rc = fget(fid2,c,256);
22935     +           _msg_=sysmsg();
22936     +           /* put rc= c= _msg_=; */
22937     +           rc = fput(fid1,strip(c));
22938     +           rc = fwrite(fid1);
22939     +         end;
22940     +         _msg_=sysmsg();
22941     +         put _msg_=;
22942     +       rc = fclose(fid1);
22943     +       rc = fclose(fid2);
22944     +     run;
22945     +%mend appendfiles;
22946     +
22947     +%macro buildOptScoreCode;
22948     +
22949     +    %em_register(key=BINCODE, type=FOLDER);
22950     +
22951     +    filename x catalog 'sashelp.emutil.em_deldir.source';
22952     +    %inc x;
22953     +    filename x;
22954     +    %delDir(folder=%nrbquote(&em_user_bincode));
22955     +
22956     +    data _null_; length rc $200;
22957     +       rc = dcreate('BINCODE', "&EM_NODEDIR");
22958     +    run;
22959     +
22960     +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
22961     +
22962     +    %let dsid = %sysfunc(open(class_nosv));
22963     +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
22964     +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
22965     +
22966     +    %let oldname=;
22967     +    %do %while(^%sysfunc(fetch(&dsid)));
22968     +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
22969     +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
22970     +
22971     +        %if &name ne &oldname %then %do;
22972     +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
22973     +             data _null_;
22974     +                length string $200 flag endflag 8;
22975     +                retain string flag endflag;
22976     +                set class_nosv end=eof;
22977     +                where DISPLAY_VAR ="&name";
22978     +                by _variable_ _group_;
22979     +                file _F1;
22980     +                index = kindex(_variable_, "BIN_");
22981     +                if index gt 0 then do;
22982     +                   if first._variable_ then do;
22983     +                      put ' ';
22984     +                      put "&EM_CODEBAR;";
22985     +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
22986     +                      put string;
22987     +                      put "&EM_CODEBAR;";
22988     +
22989     +                      if origLabel ne "" then do;
22990     +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
22991     +                            put string;
22992     +                            string = tranwrd(origLabel,"'","''");
22993     +                            string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
22994     +                            put string;
22995     +                      end;
22996     +                      else do;
22997     +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
22998     +                             put string;
22999     +                      end;
23000     +
23001     +                      put ' ';
23002     +
23003     +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23004     +                      put string;
23005     +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23006     +                      put string;
23007     +                      put "end;";
23008     +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23009     +                      put string;
23010     +                   end;
23011     +                   if first._group_ then do;
23012     +                      flag = 0;
23013     +                      endflag = 1;
23014     +                      if ^first._variable_ then do;
23015     +                         put "else";
23016     +                      end;
23017     +                      if LB ne . then do;
23018     +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
23019     +                      end;
23020     +                      else do;
23021     +                         flag = 1;
23022     +                         string = "if";
23023     +                      end;
23024     +                   end;
23025     +                   if last._Group_ then do;
23026     +                      if UB ne . then do;
23027     +                        if flag ne 1 then do;
23028     +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
23029     +                        end;
23030     +                        else do;
23031     +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
23032     +                        end;
23033     +                      end;
23034     +                      else do;
23035     +                         if flag=1 then do;
23036     +                            string = strip(DISPLAY_VAR) ;
23037     +                            string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
23038     +                            endflag=0;
23039     +                            string="";
23040     +                         end;
23041     +                         else do;
23042     +                            string = strip(string)!!" then do;";
23043     +                         end;
23044     +                      end;
23045     +                      put string;
23046     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23047     +                      put string;
23048     +                      if endflag eq 1 then do;
23049     +                        put "end;";
23050     +                      end;
23051     +                   end;
23052     +                   if last._variable_ then do;
23053     +                     string = "end;";
23054     +                     put string;
23055     +                   end;
23056     +
23057     +                end;
23058     +                else do;
23059     +                   _split_value_ = tranwrd(_split_value_,"'","''");
23060     +                   if first._group_ then do;
23061     +                      flag=0;
23062     +                      if ^first._variable_ then
23063     +                         put 'else';
23064     +                      else do;
23065     +                         put ' ';
23066     +                         put "&EM_CODEBAR;";
23067     +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
23068     +                         put string;
23069     +                         put "&EM_CODEBAR;";
23070     +
23071     +                         if origLabel ne "" then do;
23072     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
23073     +                               put string;
23074     +                               string = tranwrd(origLabel,"'","''");
23075     +                               string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
23076     +                               put string;
23077     +                         end;
23078     +                         else do;
23079     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
23080     +                               put string;
23081     +                         end;
23082     +
23083     +                         put ' ';
23084     +
23085     +                         if format ne '' then do;
23086     +                            if first._variable_ then do;
23087     +                               string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
23088     +                               put string;
23089     +                               string = '%dmnormip(_UFormat);';
23090     +                               put string;
23091     +
23092     +                               string ="if MISSING(_UFORMAT) then do;";
23093     +                               put string;
23094     +                               string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23095     +                               put string;
23096     +                               put "end;";
23097     +
23098     +                               string="else if NOT MISSING(_UFORMAT) then do;";
23099     +                               put string;
23100     +
23101     +                            end;
23102     +                         end;
23103     +                         else do;
23104     +                            if type = 'N' then do;
23105     +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23106     +                              put string;
23107     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23108     +                              put string;
23109     +                              put "end;";
23110     +
23111     +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23112     +                              put string;
23113     +                            end;
23114     +                            else if type='C' then do;
23115     +                              string = "_UFormat = "||strip(DISPLAY_VAR)||";";
23116     +                              put string;
23117     +                              string = '%dmnormip(_UFormat);';
23118     +                              put string;
23119     +
23120     +                              string ="if MISSING(_UFORMAT) then do;";
23121     +                              put string;
23122     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23123     +                              put string;
23124     +                              put "end;";
23125     +
23126     +                              string="else if NOT MISSING(_UFORMAT) then do;";
23127     +                              put string;
23128     +                              string = '%dmnormip(_UFormat);';
23129     +                              put string;
23130     +                           end;
23131     +                         end;
23132     +                      end;
23133     +                      if format ne '' OR type='C' then do;
23134     +                        string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
23135     +                      end;
23136     +                      else do;
23137     +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
23138     +                      end;
23139     +                   end;
23140     +                   else do;
23141     +                      if flag ne 1 then do;
23142     +                       if format ne '' OR type='C' then do;
23143     +                         tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
23144     +                       end;
23145     +                       else do;
23146     +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
23147     +                       end;
23148     +                         length = length(tempstring);
23149     +
23150     +                         if length < 195 then do;
23151     +                            string = tempstring;
23152     +                         end;
23153     +                         else do;
23154     +
23155     +                            string = strip(string);
23156     +                            put string;
23157     +                            string = ") then do;";
23158     +                            put string;
23159     +
23160     +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23161     +                            put string;
23162     +                            put "end;";
23163     +
23164     +                            put 'else';
23165     +                            if format ne '' OR type='C' then do;
23166     +                              string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
23167     +                            end;
23168     +                            else do;
23169     +                              string = "if "!!strip(DISPLAY_VAR)!!" eq ("!!strip(_split_value_);
23170     +                            end;
23171     +                         end;
23172     +                      end;
23173     +                   end;
23174     +
23175     +                   if last._group_ then do;
23176     +                      string = strip(string);
23177     +                      put string;
23178     +
23179     +                      string = ") then do;";
23180     +                      put string;
23181     +
23182     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23183     +                      put string;
23184     +                      put "end;";
23185     +                   end;
23186     +
23187     +                   if last._variable_ then do;
23188     +                     put "else do;";
23189     +
23190     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23191     +                     put string;
23192     +
23193     +                     put "end;";
23194     +                     put "end;";
23195     +                   end;
23196     +                end;
23197     +             run;
23198     +
23199     +             %let oldname = &name;
23200     +        %end;
23201     +    %end;
23202     +    %let dsid = %sysfunc(close(&dsid));
23203     +
23204     +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
23205     +    data _null_;
23206     +       file _F1;
23207     +       put "length _UFormat $200;";
23208     +       put "drop _UFormat;";
23209     +       put "_UFormat='';";
23210     +    run;
23211     +    filename _F1;
23212     +
23213     +   %em_register(key=EMSCOREVAR, type=DATA);
23214     +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
23215     +   proc datasets lib=&em_lib nolist;
23216     +      delete &scorevarDs;
23217     +   run;
23218     +   quit;
23219     +
23220     +   %let filrf=mydir;
23221     +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
23222     +   %let did=%sysfunc(dopen(&filrf));
23223     +
23224     +   %if &did %then %do;  %PUT  did= &did;
23225     +       %let memcount=%sysfunc(dnum(&did));
23226     +       %if &memcount > 0 %then %do;
23227     +           data &em_user_emscorevar;
23228     +              length Name $32 formula $70 file $200;
23229     +              keep NAME Formula file;
23230     +              formula  = '';
23231     +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
23232     +               name=''; file="BINCODE&em_dsep._ALL_.sas";
23233     +               output;
23234     +           %end;
23235     +           %do i=1 %to &memcount;
23236     +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
23237     +               %let newvar = %scan(&name, 1, .);
23238     +               %if "&newvar" ne "_ALL_" %then %do;
23239     +                   name = "&newvar"; file="BINCODE&em_dsep&name";
23240     +                   output;
23241     +               %end;
23242     +           %end;
23243     +
23244     +           run;
23245     +       %end;
23246     +       %let did = %sysfunc(dclose(&did));
23247     +  %end;
23248     +
23249     +   %doendu:
23250     +%mend buildOptScoreCode;
23251     +
23252     +
23253     +%macro buildScoreCode(flowCode, publishCode);
23254     +
23255     +
23256     +  filename x "&flowCode";
23257     +
23258     +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
23259     +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
23260     +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
23261     +
23262     +  data temp;
23263     +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
23264     +    by display_var _Split_value_;
23265     +     if upcase(_Split_value_) ne 'MISSING';
23266     +   run;
23267     +
23268     +   data temp_missing;
23269     +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP)) &EM_USER_BINMAPPINGS(rename=(
23270     +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
23271     +     by display_var _Split_value_;
23272     +     if upcase(_Split_value_) eq 'MISSING';
23273     +     keep _variable_ display_var missgrp;
23274     +   run;
23275     +
23276     +   proc sort data=temp_missing; by display_var missgrp; run;
23277     +
23278     +   data temp_missing;
23279     +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
23280     +     by display_var missgrp;
23281     +     if ^_a then delete;
23282     +     keep _variable_ display_var missgrp ;
23283     +   run;
23284     +
23285     +   data temp;
23286     +     merge temp temp_missing;
23287     +     by display_var;
23288     +     if display_Var eq '' then delete;
23289     +    run;
23290     +
23291     +    /* pull in wtev values */
23292     +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
23293     +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
23294     +    proc sort data=temp;  by display_var _group_; run;
23295     +
23296     +   data temp;
23297     +      merge temp tempcoarse(keep=display_var _group_  role) ;
23298     +      by display_var _group_;
23299     +    run;
23300     +
23301     +    data temp;
23302     +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
23303     +      by display_var;
23304     +
23305     +      if _group_ = . then delete;
23306     +      if _variable_ = '' then delete;
23307     +    run;
23308     +
23309     +    proc sort data=temp out=class;
23310     +       by _variable_ _group_ LB;
23311     +    run;
23312     +
23313     +    data _null_;
23314     +      file X;
23315     +
23316     +      put "length _UFormat $200;";
23317     +      put "drop _UFormat;";
23318     +      put "_UFormat='';";
23319     +    run;
23320     +
23321     +    data class_nosv;
23322     +      set class;
23323     +      if upcase(role)="INPUT";
23324     +    run;
23325     +
23326     +    data _null_;
23327     +       file X MOD;
23328     +       length string $200 flag endflag 8;
23329     +       retain string flag endflag;
23330     +       set class_nosv end=eof;
23331     +       by _variable_ _group_;
23332     +
23333     +       index = kindex(_variable_, "BIN_");
23334     +       if index gt 0 then do;
23335     +
23336     +         if first._variable_ then do;
23337     +            put ' ';
23338     +            put "&EM_CODEBAR;";
23339     +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
23340     +            put string;
23341     +            put "&EM_CODEBAR;";
23342     +
23343     +
23344     +            if origLabel ne "" then do;
23345     +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
23346     +              put string;
23347     +              string = tranwrd(origLabel,"'","''");
23348     +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
23349     +              put string;
23350     +            end;
23351     +            else do;
23352     +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
23353     +             put string;
23354     +            end;
23355     +
23356     +            put ' ';
23357     +
23358     +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23359     +            put string;
23360     +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23361     +            put string;
23362     +            put "end;";
23363     +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23364     +            put string;
23365     +          end;
23366     +           if first._group_ then do;
23367     +              flag = 0;
23368     +              endflag = 1;
23369     +              if ^first._variable_ then do;
23370     +                put "else";
23371     +              end;
23372     +              if LB ne . then do;
23373     +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
23374     +              end;
23375     +              else do;
23376     +                 flag = 1;
23377     +                 string = "if";
23378     +              end;
23379     +
23380     +           end;
23381     +           if last._Group_ then do;
23382     +              if UB ne . then do;
23383     +                if flag ne 1 then do;
23384     +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
23385     +                end;
23386     +                else do;
23387     +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
23388     +                end;
23389     +              end;
23390     +              else do;
23391     +                 if flag=1 then do;
23392     +                   string = strip(DISPLAY_VAR) ;
23393     +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
23394     +                   endflag = 0;
23395     +                   string="";
23396     +                 end;
23397     +                 else do;
23398     +                   string = strip(string)!!" then do;";
23399     +                 end;
23400     +              end;
23401     +              put string;
23402     +
23403     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23404     +              put string;
23405     +              if endflag eq 1 then do;
23406     +                put "end;";
23407     +              end;
23408     +           end;
23409     +           if last._variable_ then do;
23410     +             string = "end;";
23411     +             put string;
23412     +           end;
23413     +       end;
23414     +       else do;
23415     +           _split_value_ = tranwrd(_split_value_,"'","''");
23416     +           if first._group_ then do;
23417     +              flag=0;
23418     +              if ^first._variable_ then
23419     +                 put 'else';
23420     +              else do;
23421     +                 put ' ';
23422     +                 put "&EM_CODEBAR;";
23423     +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
23424     +                 put string;
23425     +                 put "&EM_CODEBAR;";
23426     +
23427     +                 if origLabel ne "" then do;
23428     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
23429     +                   put string;
23430     +                   string = tranwrd(origLabel,"'","''");
23431     +                   string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
23432     +                   put string;
23433     +                 end;
23434     +                 else do;
23435     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
23436     +                   put string;
23437     +                 end;
23438     +
23439     +                 put ' ';
23440     +
23441     +                if format ne '' then do;
23442     +                  if first._variable_ then do;
23443     +                    string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
23444     +                    put string;
23445     +                    string = '%dmnormip(_UFormat);';
23446     +                    put string;
23447     +
23448     +                     string ="if MISSING(_UFORMAT) then do;";
23449     +                     put string;
23450     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23451     +                     put string;
23452     +                     put "end;";
23453     +
23454     +                     string="else if NOT MISSING(_UFORMAT) then do;";
23455     +                     put string;
23456     +
23457     +                  end;
23458     +                end;
23459     +                else do;
23460     +                     if type = 'N' then do;
23461     +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23462     +                       put string;
23463     +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23464     +                       put string;
23465     +                       put "end;";
23466     +
23467     +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
23468     +                       put string;
23469     +
23470     +                     end;
23471     +                     else if type='C' then do;
23472     +                        string = "_UFormat = "||strip(DISPLAY_VAR)||";";
23473     +                        put string;
23474     +                        string = '%dmnormip(_UFormat);';
23475     +                        put string;
23476     +
23477     +                        string ="if MISSING(_UFORMAT) then do;";
23478     +                        put string;
23479     +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23480     +                        put string;
23481     +                        put "end;";
23482     +
23483     +                        string="else if NOT MISSING(_UFORMAT) then do;";
23484     +                        put string;
23485     +                        string = '%dmnormip(_UFormat);';
23486     +                        put string;
23487     +                    end;
23488     +                end;
23489     +              end;
23490     +              if format ne '' OR type='C' then do;
23491     +                string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
23492     +              end;
23493     +              else do;
23494     +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
23495     +              end;
23496     +           end;
23497     +           else do;
23498     +              if flag ne 1 then do;
23499     +                if format ne '' OR type='C' then do;
23500     +                  tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
23501     +                end;
23502     +                else do;
23503     +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
23504     +                end;
23505     +                length = klength(tempstring);
23506     +
23507     +                if length < 195 then do;
23508     +                   string = tempstring;
23509     +                end;
23510     +                else do;
23511     +
23512     +                   string = strip(string);
23513     +                   put string;
23514     +                   string = ") then do;";
23515     +                   put string;
23516     +
23517     +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23518     +                   put string;
23519     +                   put "end;";
23520     +
23521     +                 /*  string = strip(string)||",'...';"; */
23522     +
23523     +                   put 'else';
23524     +                   if format ne '' OR type='C' then do;
23525     +                     string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
23526     +                   end;
23527     +                   else do;
23528     +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
23529     +                   end;
23530     +
23531     +
23532     +                end;
23533     +              end;
23534     +           end;
23535     +
23536     +           if last._group_ then do;
23537     +              string = strip(string);
23538     +              put string;
23539     +              string = ") then do;";
23540     +              put string;
23541     +
23542     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
23543     +              put string;
23544     +              put "end;";
23545     +           end;
23546     +
23547     +           if last._variable_ then do;
23548     +             put "else do;";
23549     +
23550     +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
23551     +             put string;
23552     +
23553     +             put "end;";
23554     +             put "end;";
23555     +           end;
23556     +         *end;
23557     +       end;
23558     +    run;
23559     +
23560     +    /* generate PublishCode the same as flowscorecode */
23561     +    filename Y "&publishCode";
23562     +
23563     +    /* if publishCode already exists, wipe it out first */
23564     +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
23565     +      %let rc = %sysfunc(fdelete(Y));
23566     +    %end;
23567     +
23568     +    %appendfiles(Y, X);
23569     +
23570     +    %if %EM_BINARY_TARGET= %then %do;
23571     +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
23572     +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet, where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")), nummacro=em_num_interval_Target);
23573     +      %end;
23574     +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
23575     +      %let ibn_inttarget_orig = &ibn_inttarget;
23576     +
23577     +      %if %symexist(IGNBinTarget)=0 %then %do;
23578     +         %global ignbintarget ignfreqvar;
23579     +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
23580     +         %include temp;
23581     +         filename temp;
23582     +         %getVarName(&EM_IMPORT_DATA, BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))), IGNBinTarget);
23583     +
23584     +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
23585     +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
23586     +         %end;
23587     +      %end;
23588     +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
23589     +         proc sql noprint;
23590     +            %if %EM_FREQ ne %then %do;
23591     +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
23592     +            %end;
23593     +            %else %do;
23594     +               select mean(&ibn_inttarget)
23595     +            %end;
23596     +            into :ignbincut trimmed from &EM_IMPORT_DATA;
23597     +         quit;
23598     +      %end;
23599     +
23600     +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
23601     +      %if &dsid %then %do;
23602     +         %let tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
23603     +         %let rc=%sysfunc(close(&dsid));
23604     +      %end;
23605     +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
23606     +
23607     +      data _null_;
23608     +         file x mod;
23609     +         put ' ';
23610     +
23611     +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
23612     +             put "&EM_CODEBAR;";
23613     +             %let note = Mean Cutoff Binary Transformation for Target;
23614     +             put "* &note;";
23615     +             put "&EM_CODEBAR;";
23616     +         %end;
23617     +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
23618     +             put "&EM_CODEBAR;";
23619     +             %let note = User-Specified Cutoff Binary Transformation for Target;
23620     +             put "* &note;";
23621     +             put "&EM_CODEBAR;";
23622     +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
23623     +         %end;
23624     +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
23625     +         put "else do;";
23626     +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
23627     +         put "   else &IGNBinTarget=0;";
23628     +         put "end;";
23629     +
23630     +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
23631     +      run;
23632     +
23633     +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
23634     +
23635     +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
23636     +
23637     +         data _null_;
23638     +            file deltaref;
23639     +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
23640     +            put "if name='&IGNBinTarget' then do;";
23641     +            put "   role='TARGET';";
23642     +            put "   level='BINARY';";
23643     +            put "end;";
23644     +         run;
23645     +
23646     +      %end;
23647     +      %else %do;
23648     +
23649     +         data _null_;
23650     +            file deltaref;
23651     +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
23652     +            put "if name='&IGNBinTarget' then do;";
23653     +            put "   role='REJECTED';";
23654     +            put "   level='BINARY';";
23655     +            put "end;";
23656     +         run;
23657     +      %end;
23658     +
23659     +      filename deltaref;
23660     +
23661     +   %end;
23662     +
23663     +    filename X;
23664     +    filename Y;
23665     +
23666     +    %buildOptScoreCode;
23667     +
23668     +    proc datasets library=work nolist;
23669     +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
23670     +    run;
23671     +    quit;
23672     +
23673     +%mend buildScoreCode;
23674     +
23675     +%macro buildMetaCode(DeltaCodeFile=);
23676     +
23677     +   /* set variable roles based on New Role column in the Results table */
23678     +   data _null_;
23679     +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
23680     +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
23681     +      %if &dsid %then %do;
23682     +        %let obs = %sysfunc(fetch(&dsid));
23683     +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
23684     +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
23685     +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
23686     +
23687     +        %do %while(&obs=0);
23688     +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
23689     +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
23690     +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
23691     +
23692     +          /* retrieve grp and woe names from varmappings dataset */
23693     +          %let choice = _VARIABLE_ = "&inputname";
23694     +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
23695     +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
23696     +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
23697     +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
23698     +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
23699     +
23700     +          put "if name = '&inputname' then role='REJECTED';";
23701     +          %if "&role" ne "DEFAULT" %then %do;
23702     +            put "if name = '&grpname' then role='&role';";
23703     +          %end;
23704     +          %else %do;
23705     +            put "if name = '&grpname' then role='&oldrole';";
23706     +          %end;
23707     +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
23708     +
23709     +          %let obs = %sysfunc(fetch(&dsid));
23710     +        %end;
23711     +      %end;
23712     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
23713     +   run;
23714     +
23715     +   /* drop all vars in the splitvals dataset that aren't present in the varmappings dataset */
23716     +   data _null_;
23717     +      file &DeltaCodeFile MOD;
23718     +
23719     +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
23720     +      %if &sdsid %then %do;
23721     +        %let sobs = %sysfunc(fetch(&sdsid));
23722     +        %do %while(&sobs=0);
23723     +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
23724     +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
23725     +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
23726     +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
23727     +
23728     +          %let checkgrp = GRP_&checkname;
23729     +          %let lenname = %length(&checkgrp);
23730     +          %if %eval(&lenname-32) > 0 %then %do;
23731     +            %let checkgrp = %substr(&checkgrp, 1, 32);
23732     +          %end;
23733     +
23734     +          %let choice = _VARIABLE_ ="&checkname";
23735     +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
23736     +
23737     +          /* if var not found in varmappings, delete variables; */
23738     +          /* this could happen when freeze=Y and vars in the frozen dataset aren't in the incoming training data */
23739     +          %if &vdsid eq 0 %then %do;
23740     +            put 'if name="&displayvar" then delete;';
23741     +            %let dispgrp = GRP_&displayvar;
23742     +            put 'if name="&dispgrp" then delete;';
23743     +          %end;
23744     +
23745     +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
23746     +          %let sobs = %sysfunc(fetch(&sdsid));
23747     +        %end;
23748     +      %end;
23749     +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
23750     +   run;
23751     +
23752     +%mend buildMetaCode;
23753     +
23754     +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
23755     +
23756     +   proc sort data=&coarse out=sortedcoarse nodupkey;
23757     +     by display_var;
23758     +   run;
23759     +   proc sort data=&varmappings nodupkey;
23760     +     by _variable_;
23761     +   run;
23762     +   %if %sysfunc(exist(&resultstable, data)) %then %do;
23763     +     proc sort data=&resultstable; by display_var; run;
23764     +   %end;
23765     +
23766     +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
23767     +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
23768     +     %if %sysfunc(exist(&resultstable, data)) %then %do;
23769     +        &resultstable (keep = display_var _new_role_ )
23770     +     %end;
23771     +     ;
23772     +     by display_var;
23773     +     length _role_ _new_role_ $10;
23774     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
23775     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel , NOQUOTE))"
23776     +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel, NOQUOTE))"
23777     +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel, NOQUOTE))"
23778     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))"
23779     +           ;
23780     +
23781     +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
23782     +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
23783     +                _role_ = "Rejected";
23784     +             else _role_ = "Input";
23785     +           %end;
23786     +           %else %do;
23787     +             _role_ = "Input";
23788     +           %end;
23789     +           if _new_role_ eq "" then _new_role_="Default";
23790     +      if ^_a then do;
23791     +        _gini_ = 0;
23792     +        _role_ = 'Rejected';
23793     +        if _new_role_ eq "" then _new_role_="Default";
23794     +      end;
23795     +   run;
23796     +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL rename=(NAME=display_var LABEL=_label_));
23797     +     by NAME;
23798     +   run;
23799     +   data outlabel;
23800     +     set outlabel;
23801     +     if _label_ = '' then _label_ = _variable_;
23802     +   run;
23803     +   data &resultstable;
23804     +     merge &resultstable(in=_a_) outlabel;
23805     +     by display_Var;
23806     +     if _a_ then output;
23807     +   run;
23808     +   proc datasets library=work nolist;
23809     +     delete sortedcoarse outlabel;
23810     +   run;
23811     +   quit;
23812     +   proc sort data=&resultstable nodupkey;
23813     +      by DESCENDING
23814     +        _gini_ display_Var;
23815     +   run;
23816     +   data &resultstable;
23817     +     set &resultstable;
23818     +
23819     +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))"
23820     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))";
23821     +     giniOrder = _N_;
23822     +     _gini_ = round(_GINI_, .001);
23823     +     drop _variable_;
23824     +   run;
23825     +
23826     +   proc print data=&resultstable label;
23827     +   run;
23828     +
23829     +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
23830     +   data &coarse;
23831     +     set &coarse;
23832     +     length role $10;
23833     +     %let dsid = %sysfunc(open(&resultstable));
23834     +     %if &dsid %then %do;
23835     +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
23836     +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
23837     +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
23838     +
23839     +       %let obs = %sysfunc(fetch(&dsid));
23840     +       %do %while(&obs=0);
23841     +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
23842     +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
23843     +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
23844     +
23845     +                                                                                               if DISPLAY_VAR = "&displayVar" then do;
23846     +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))";
23847     +            giniOrder = &order;
23848     +            role = "&role";
23849     +          end;
23850     +
23851     +          %let obs = %sysfunc(fetch(&dsid));
23852     +       %end;
23853     +     %end;
23854     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
23855     +   run;
23856     +
23857     +
23858     +%mend EM_GENERATE_RESULTSTABLE;
23859     +
23860     +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
23861     +
23862     +    /* instantiate the zchar macro to be used in adding bin definition */
23863     +    filename _temp catalog 'sashelp.emmacs.zchar.source';
23864     +    %inc _temp;
23865     +    filename _temp;
23866     +
23867     +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
23868     +      by _variable_ binFlag _group_ LB;
23869     +    run;
23870     +
23871     +    data tempExport;
23872     +      set sortedFine;
23873     +      by _variable_ binFlag _group_;
23874     +      length _split_value_ $200;
23875     +
23876     +      /* for all binned variables, need to modify the split value to original cutoff as well as change level to interval */
23877     +      if binFlag = 0 then do;
23878     +        index = kindex(_variable_, "BIN_");
23879     +        if index gt 0 then do;
23880     +          _LEVEL_ = "INTERVAL";
23881     +        end;
23882     +        _Split_value_ = _split_value_;
23883     +        output;
23884     +      end;
23885     +      else do;
23886     +         * if last._group_ then do;
23887     +          index = kindex(_variable_, "BIN_");
23888     +          if index gt 0 then do;
23889     +            _LEVEL_ = "INTERVAL";
23890     +          end;
23891     +          _Split_value_ = %zchar(UB);
23892     +          output;
23893     +         * end;
23894     +      end;
23895     +
23896     +      rename display_Var = _variable_;
23897     +      keep display_var _level_ _group_ _split_value_ binFlag;
23898     +    run;
23899     +
23900     +    %if &CREATEMETHOD eq OVERWRITE %then %do;
23901     +       data &EXPORTGROUPING;
23902     +         set tempexport;
23903     +       run;
23904     +    %end;
23905     +    %else %do;
23906     +       /* determine if EXPORTGROUPING already exists */
23907     +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
23908     +         data &EXPORTGROUPING;
23909     +            set &EXPORTGROUPING tempexport;
23910     +         run;
23911     +       %end;
23912     +       %else %do;
23913     +         data &EXPORTGROUPING;
23914     +            set tempexport;
23915     +         run;
23916     +       %end;
23917     +    %end;
23918     +
23919     +    proc datasets lib=work nolist;
23920     +      delete sortedFine tempexport;
23921     +    run;
23922     +    quit;
23923     +
23924     +%mend EM_GENERATE_EXPORTGROUP;
23925     +
23926     +
23927     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
23930     +%macro train;
23932     +   /* include training macros */
23933     +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
23934     +   %include trtemp;
23935     +   filename trtemp;
23937     +   /* trick IGN into thinking it is a model node to build decmeta; further down, set %EM_MODEL ASSESS=N
23938     +   %let EM_TOOLTYPE = MODEL; */
23940     +   %if &EM_IMPORT_DATA eq %then %do;
23941     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
23942     +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note , NOQUOTE));
23943     +       %put &em_codebar;
23944     +       %put &errmsg;
23945     +       %put &em_codebar;
23946     +       %goto doendm;
23947     +   %end;
23949     +   %if  &EM_NUM_TARGET ne 1 %then %do;
23950     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
23951     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
23952     +        %put &em_codebar;
23953     +        %put &errmsg;
23954     +        %put &em_codebar;
23955     +        %goto doendm;
23956     +   %end;
23958     +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
23959     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
23960     +        %put &em_codebar;
23961     +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
23962     +        %put &errormsg;
23963     +        %put &em_codebar;
23964     +        %goto doendm;
23965     +   %end;
23967     +   /* Initialize property macro variables */
23968     +   %SetProperties;
23969     +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
23971     +   /* check actual num of target levels */
23972     +   %let target_level = %EM_TARGET_LEVEL;
23973     +   %let target_var = %EM_TARGET;
23974     +   %if (&target_Level eq BINARY) %then %do;
23975     +      /* retrieve target information */
23976     +      /* does decmeta exist?  If not, retrieve target information elsewhere */
23977     +      %global target_event;
23978     +      %let target_event=;
23979     +      %if "&EM_DEC_DECMETA" eq "" %then %do;
23980     +        /* retrieve type and format from variableset */
23981     +        %let eventorder = DESC;
23982     +        data temp;
23983     +          set &EM_DATA_VARIABLESET;
23984     +          where NAME ="%EM_BINARY_TARGET";
23985     +        run;
23986     +        %let dsid = %sysfunc(open(work.temp));
23987     +        %if &dsid %then %do;
23988     +          %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
23989     +          %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
23990     +          %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
23991     +          %let obs = %sysfunc(fetchobs(&dsid, 1));
23992     +          %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
23993     +          %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
23994     +          %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
23995     +          %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
23996     +             %else
23997     +          %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
23998     +             %else
23999     +          %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
24000     +             %else
24001     +          %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
24002     +        %end;
24003     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24005     +        /* retrieve target_event and Target_nonEvent values */
24006     +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET))) classout=EVENTOUT;
24007     +          target %EM_BINARY_TARGET;
24008     +          class  %EM_BINARY_TARGET(&eventorder);
24009     +        run;
24011     +        data _null_;
24012     +          dsid = open("EVENTOUT");
24013     +          if dsid>0 then do;
24014     +          levelnum = VARNUM(dsid, "LEVEL");
24015     +          if levelnum then do;
24016     +            if ^fetch(dsid) then
24017     +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
24019     +            if ^fetch(dsid) then
24020     +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
24021     +          end;
24022     +          dsid=close(dsid);
24023     +          end;
24024     +        run;
24025     +        proc datasets library=work nolist;
24026     +           delete eventout;
24027     +        run;
24028     +        quit;
24029     +      %end;
24030     +      %else %do;
24031     +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
24033     +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
24034     +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
24035     +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
24037     +         %do %while(^ %sysfunc(fetch(&dsid)));
24038     +            %let Target_Event = %sysfunc(getvarc(&dsid, &vn_event));
24039     +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
24040     +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
24041     +         %end;
24042     +         %let dsid = %sysfunc(close(&dsid));
24044     +         %let dsid=%sysfunc(open(&EM_DEC_DECDATA));
24045     +           %let obs = %sysfunc(fetchobs(&dsid, 2));
24046     +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
24047     +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
24048     +         %let dsid = %sysfunc(close(&dsid));
24049     +      %end;
24051     +      %global ignbintarget;
24052     +      %let ignbintarget = %EM_BINARY_TARGET;
24054     +      data &EM_USER_NEWTRAIN;
24055     +        set &EM_IMPORT_DATA;
24056     +      run;
24057     +   %end;
24058     +   %else %do; /* preprocessing for interval target */
24059     +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
24060     +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
24061     +            var &target_var;
24062     +         run;
24064     +         data _null_;
24065     +            set minmax;
24066     +            call symput('tarmax',strip(max));
24067     +            call symput('tarmin',strip(min));
24068     +         run;
24070     +         /* cutoff can equal tarmin but not tarmax */
24071     +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or %sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
24072     +            %let EMEXCEPTIONSTRING = exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
24073     +            %put &em_codebar;
24074     +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error, NOQUOTE, &tarmin, &tarmax));
24075     +            %put &errormsg;
24076     +            %put &em_codebar;
24077     +            %goto doendm;
24078     +         %end;
24079     +      %end;
24081     +      %global ignbintarget;
24082     +      %getVarName(&EM_IMPORT_DATA, BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))), IGNBinTarget);
24084     +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLevels=igntbinlevs);
24085     +      %if &igntbinlevs ne 2 %then %do;
24086     +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
24087     +         %put &em_codebar;
24088     +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error, NOQUOTE));
24089     +         %put &errormsg;
24090     +         %put &em_codebar;
24091     +         %goto doendm;
24092     +      %end;
24094     +      %let Target_Event = 1;
24095     +      %let Target_NonEvent = 0;
24096     +      %let Target_Type = BINARY;
24097     +      %let Target_Format = ;
24099     +   %end;
24101     +   /* data sets */
24102     +   %EM_GETNAME(key=BINDATA,        type=DATA);
24103     +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
24104     +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
24105     +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
24106     +   %EM_GETNAME(key=COARSE,          type=DATA);
24107     +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
24108     +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
24110     +   /* files */
24111     +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
24112     +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
24114     +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
24115     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
24116     +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
24117     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
24118     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE));
24120     +        %put &em_codebar;
24121     +        %put &errmsg;
24122     +        %put &em_codebar;
24123     +        %goto doendm;
24124     +     %end;
24125     +   %end;
24127     +   %global useImport;
24128     +   %let useImport = 0;
24130     +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
24132     +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
24133     +     proc datasets library=&EM_LIB nolist;
24134     +       delete &EM_NODEID._IMPORTSUBSET;
24135     +     run;
24136     +     quit;
24137     +   %end;
24139     +   /* if importGrouping=Y, verify that data and all vars exist and are of the correct type */
24140     +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
24142     +     /* if import eq Y and no importtable exists, throw an exception */
24143     +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
24144     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
24145     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
24147     +        %put &em_codebar;
24148     +        %put &errmsg;
24149     +        %put &em_codebar;
24150     +        %goto doendm;
24151     +     %end;
24153     +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
24154     +      %if &dsid %then %do;
24155     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24156     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
24157     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
24158     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
24160     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
24161     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
24162     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
24163     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
24164     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
24165     +         %end;
24166     +      %end;
24167     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24169     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
24170     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
24172     +        /* generate subset of data that contains those vars also found in training data and add display_var information */
24173     +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
24174     +           by _VARIABLE_ ;
24175     +        run;
24177     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
24178     +          by NAME;
24179     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
24180     +        run;
24182     +        data &EM_USER_IMPORTSUBSET;
24183     +          merge tempimport(in=_a) tempvarset(in=_b);
24184     +          length display_Var $32;
24185     +          by _VARIABLE_;
24186     +          display_var = _Variable_;
24187     +          if _a and _b then output;
24188     +        run;
24190     +        proc datasets library=work nolist;
24191     +          delete tempimport tempvarset;
24192     +        run;
24193     +        quit;
24195     +        %end;
24196     +      %end;
24197     +   %end;
24199     +   /* set useImport flag if there are obs in the importSubset dataset */
24200     +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
24201     +   %if &dsid %then %do;
24202     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
24203     +     %if &nobs gt 0 %then %let useimport = 1;
24204     +   %end;
24205     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24207     +   %global useFreeze;
24208     +   %let useFreeze = 0;
24210     +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type */
24211     +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
24213     +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
24214     +     proc datasets library=&EM_LIB nolist;
24215     +       delete &EM_NODEID._FREEZESUBSET;
24216     +     run;
24217     +     quit;
24218     +   %end;
24220     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
24222     +      /* create freezesubset data to contain information on pre-binned data and raw values */
24223     +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
24225     +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
24226     +      %if &dsid %then %do;
24227     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24228     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
24229     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
24230     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
24232     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
24233     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
24234     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
24235     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
24236     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
24237     +         %end;
24238     +      %end;
24239     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24241     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
24242     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
24244     +        /* generate subset of data that contains those vars also found in training data */
24245     +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
24246     +           by _VARIABLE_ ;
24247     +        run;
24249     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
24250     +          by NAME;
24251     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
24252     +        run;
24254     +        data &EM_USER_FREEZESUBSET;
24255     +          merge tempfreeze(in=_a) tempvarset(in=_b);
24256     +          length display_Var $32;
24257     +          by _VARIABLE_;
24258     +          display_var = _Variable_;
24259     +          if _a and _b then output;
24260     +        run;
24262     +        proc datasets library=work nolist;
24263     +          delete tempfreeze tempvarset;
24264     +        run;
24265     +        quit;
24266     +        %end;
24267     +      %end;
24268     +   %end;
24270     +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
24271     +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
24272     +   %if &dsid %then %do;
24273     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
24274     +     %if &nobs gt 0 %then %let useFreeze = 1;
24275     +   %end;
24276     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24278     +   /* if finedetail already exists, delete prior to re-run */
24279     +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
24280     +     proc datasets library=&EM_LIB nolist;
24281     +       delete &EM_NODEID._FINEDETAILDATA;
24282     +     run;
24283     +     quit;
24284     +   %end;
24286     +   data tempvarnames;
24287     +     set &EM_DATA_VARIABLESET;
24288     +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
24289     +     keep NAME LEVEL LABEL;
24290     +   run;
24292     +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
24293     +     names NAME;
24294     +     prefix WOE_ GRP_ ;
24295     +   run;
24297     +   proc sort data=tempmapping; by name; run;
24298     +   proc sort data=tempvarnames; by name; run;
24299     +   data tempmapping;
24300     +     merge tempmapping tempvarnames;
24301     +     by NAME;
24302     +     rename LEVEL=procLevel;
24303     +   run;
24305     +   /* generate initial columns of mapping table by setting grpflag=0 */
24306     +   %EM_GENERATE_MAPPING_TABLE;
24308     +   proc datasets library=work nolist;
24309     +     delete tempImport tempScore;
24310     +   run;
24311     +   quit;
24313     +   /* delete splitvals dataset if this existed prior to run */
24314     +   %let nvars=0;
24315     +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
24316     +   %if &sdsid > 0 %then %do;
24317     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
24318     +   %end;
24319     +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
24321     +   %if &nvars > 0 %then %do;
24322     +      proc datasets library=&EM_LIB nolist;
24323     +        delete &EM_NODEID._SPLITVALS;
24324     +      run;
24325     +      quit;
24326     +   %end;
24328     +   %global classvars qclassvars;
24329     +   %let classvars=;
24330     +   %let qclassvars=;
24332     +   /* generate the intervalvars and classvars macros */
24333     +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
24335     +   /* update varmappings with any changes to procLevel based on discretemid */
24336     +   data &EM_USER_VARMAPPINGS;
24337     +     set &EM_USER_VARMAPPINGS;
24338     +     /* procLevel column to indicate the level used by proc; this handles*/
24339     +     /* cases in which var is marked INTERVAL in metadat but treated as  */
24340     +     /* ordinal in prebinning because of # unique levels                 */
24341     +     %let dsid = %sysfunc(open(work._discretemid));
24342     +     %if &dsid %then %do;
24343     +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
24344     +       %let obs = %sysfunc(fetch(&dsid));
24345     +       %do %while(&obs=0);
24346     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
24347     +          if _variable_ = "&varname" then procLevel = "ORDINAL";
24348     +          %let obs = %sysfunc(fetch(&dsid));
24349     +       %end;
24350     +     %end;
24351     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24352     +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel , NOQUOTE))";
24353     +   run;
24355     +   /* generate Grp_xxx variables for interval inputs */
24356     +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
24357     +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
24359     +   %end;
24360     +   %else %do;
24361     +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
24362     +   %end;
24364     +   /* generate GRP_XXX variables for nominal inputs */
24365     +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
24367     +   /* generate GRP_XXX variables for ordinal inputs */
24368     +   %EM_ORDVARS_GROUP;
24370     +   proc print data=&EM_USER_VARMAPPINGS label;
24371     +     var _VARIABLE_ _GRP_VARIABLE_ ;
24372     +   run;
24374     +   /* add _proc_var_ to varmappings data to know names of processed variables; could be original input, could be bin_xxx */
24375     +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
24376     +     by _VARIABLE_;
24377     +   run;
24379     +   data &EM_USER_VARMAPPINGS;
24380     +     set &EM_USER_VARMAPPINGS;
24381     +     length _proc_var_ $32;
24382     +     %let dsid = %sysfunc(open(work.tempsplitvals));
24383     +     %if &dsid %then %do;
24384     +        %let obs = %sysfunc(fetch(&dsid));
24385     +        %do %while(&obs=0);
24386     +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
24387     +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
24388     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24389     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
24391     +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
24392     +          %let obs = %sysfunc(fetch(&dsid));
24393     +        %end;
24394     +     %end;
24395     +     if missing(_proc_var_) then _proc_var_=_variable_;
24396     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24397     +   run;
24399     +   proc datasets library=work nolist;
24400     +     delete sortedbin tempsplitvals;
24401     +   run;
24402     +   quit;
24404     +   /* calculate Fine Detail statistics for each input */
24405     +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
24407     +   /* apply grouping and create grouped dataset */
24408     +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
24410     +   /* generate _label_ values in the COARSE dataset from the Scored data */
24411     +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
24412     +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS, &EM_USER_COARSE);
24413     +   filename Y;
24415     +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
24416     +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
24418     +   /* generate reports */
24419     +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT, autodisplay=N, spk=N);
24422     +   %doendm:
24423     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
24425     +%macro EM_GENERATE_MAPPING_TABLE;
24427     +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
24428     +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
24429     +   length _variable_  _grp_variable_  $32 procLevel $8;
24430     +   set tempmapping;
24431     +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel , NOQUOTE))"
24432     +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel , NOQUOTE))";
24434     +         _variable_ = NAME;
24435     +         _grp_variable_ = GRP;
24436     + run;
24438     +%mend EM_GENERATE_MAPPING_TABLE;
24440     +%macro EM_PRE_BINNING(input);
24441     +    /* Determine which of our variables are interval  */
24443     +    data tempvariableset;
24444     +      set &EM_DATA_VARIABLESET;
24445     +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
24446     +    run;
24448     +    /* add all interval vars to the intervalvar macro
24449     +    %let dsid = %sysfunc(open(work.tempvariableset));
24450     +    %if &dsid %then %do;
24451     +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
24452     +       %let obs = %sysfunc(fetch(&dsid));
24453     +       %do %while(&obs=0);
24454     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
24455     +          %let intervalvars = &intervalvars &varname;
24456     +          %let obs = %sysfunc(fetch(&dsid));
24457     +       %end;
24458     +    %end;
24459     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24460     + */
24462     +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME, nummacro=num_intvars);
24464     +    /* Determine which variables marked as interval are true interval distributions; */
24465     +    /* intmid contains variables that are actually interval and should be binned; */
24466     +    /* discretemid contains variables that are actually discrete and should NOT be binned */
24467     +    %if %intervalvars ne %then %do;
24468     +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
24469     +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
24470     +        class %intervalvars;
24471     +      run;
24472     +      proc freq data=_CLASSOUT order=DATA noprint;
24473     +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
24474     +      run;
24476     +      %let _INTBINS=;
24477     +      data _null_;
24478     +        set _COUNT;
24479     +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
24480     +      run;
24482     +      proc sort data=_CLASSOUT;
24483     +        by NAME;
24484     +      run;
24485     +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
24486     +        var NRAW;
24487     +        by NAME;
24488     +      run;
24490     +      data _null_;
24491     +        dsid = open('_OUT');
24492     +        if dsid then do;
24493     +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
24494     +           csid = close(dsid);
24495     +        end;
24496     +      run;
24497     +      data _INTMID;
24498     +        set _OUT;
24499     +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
24500     +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
24501     +          if ^indexw("&_INTBINS", VARIABLE) then output;
24502     +        %end;
24503     +      run;
24505     +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
24506     +        data _DISCRETEMID;
24507     +          set _OUT;
24508     +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
24509     +          if indexw("&_INTBINS", VARIABLE) then output;
24510     +        run;
24511     +      %end;
24512     +      %else %do;
24513     +         %if %sysfunc(exist(_discretemid)) %then %do;
24514     +            proc delete data=_discretemid;
24515     +            run;
24516     +         %end;
24517     +      %end;
24519     +      /* add vars from the _DISCRETEMID dataset to the classvars macro
24520     +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
24521     +      %if &dsid %then %do;
24522     +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
24523     +        %let obs = %sysfunc(fetch(&dsid));
24525     +        %do %while(&obs=0);
24526     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
24527     +          %let classvars = &classvars &var;
24528     +          %let qclassvars = &qclassvars "&var";
24529     +          %let obs = %sysfunc(fetch(&dsid));
24530     +        %end;
24531     +      %end;
24532     +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
24533     +*/
24534     +    %end;
24535     +    %else %do;
24536     +      %if %sysfunc(exist(_intmid)) %then %do;
24537     +         proc delete data=_intmid;
24538     +         run;
24539     +      %end;
24541     +      %if %sysfunc(exist(_discretemid)) %then %do;
24542     +         proc delete data=_discretemid;
24543     +         run;
24544     +      %end;
24545     +    %end;
24547     +    /* if import grouping then remove interval vars in import data from _INTMID */
24548     +    %if &useImport eq 1 %then %do;
24550     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
24551     +        by _VARIABLE_;
24552     +      run;
24554     +      data &EM_USER_IMPORTSUBSET;
24555     +        length CODEVAR $32;
24556     +        set &EM_USER_IMPORTSUBSET;
24557     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
24558     +      run;
24560     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
24561     +        by _VARIABLE_;
24562     +      run;
24564     +      %let dsid = %sysfunc(open(work.tempsubset));
24565     +      %let nobs = 0;
24566     +      %if &dsid %then %do;
24567     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
24568     +      %end;
24569     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
24571     +      data tempsubset;
24572     +        set tempsubset;
24573     +        length  binVar suffix $32;
24574     +        array binnames{&nobs} $32 _temporary_;
24575     +        retain binVar binnames;
24576     +        by _VARIABLE_;
24578     +        binVar = 'BIN_'!!strip(CODEVAR);
24579     +        binVar = ksubstr(binVar, 1, 32);
24580     +        count = 1;
24582     +        do i=1 to _N_;
24583     +           do while(binvar eq binnames(i));
24584     +              suffix = strip(put(count,best.));
24585     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
24586     +              count + 1;
24587     +           end;
24588     +        end;
24589     +        binnames(_N_)= binvar;
24590     +        output;
24591     +        drop suffix count i;
24592     +     run;
24594     +     data &EM_USER_IMPORTSUBSET;
24595     +       set &EM_USER_IMPORTSUBSET;
24596     +       length binVar $32;
24598     +        %let dsid = %sysfunc(open(work.tempsubset));
24599     +        %if &dsid %then %do;
24600     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24601     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
24602     +          %let obs = %sysfunc(fetch(&dsid));
24604     +          %do %while(&obs=0);
24605     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
24606     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
24608     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
24609     +            %let obs = %sysfunc(fetch(&dsid));
24610     +          %end;
24611     +        %end;
24612     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24613     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
24614     +        if binVar ne "" then do;
24615     +          _LEVEL_ = "ORDINAL";
24616     +        end;
24618     +      run;
24620     +      %let idsidexists=0;
24621     +      %let idsid = %sysfunc(open(work._intmid));
24622     +      %if &idsid %then %do;
24623     +        %let idsidexists=1;
24624     +        %let idsid = %sysfunc(close(&idsid));
24625     +      %end;
24627     +      %if &idsidexists = 1 %then %do;
24628     +      data _INTMID;
24629     +        set _INTMID;
24631     +        %let dsid = %sysfunc(open(work.tempsubset));
24632     +        %if &dsid %then %do;
24633     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
24634     +          %let obs = %sysfunc(fetch(&dsid));
24636     +          %do %while(&obs=0);
24637     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
24638     +            if variable = "&codevar" then delete;
24639     +            %let obs = %sysfunc(fetch(&dsid));
24640     +          %end;
24641     +        %end;
24642     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24643     +      run;
24644     +      %end;
24646     +      proc datasets library=work nolist;
24647     +        delete tempsubset;
24648     +      run;
24649     +      quit;
24650     +    %end;
24652     +    /* if freeze then remove interval vars in import data from _INTMID */
24653     +    %if &useFreeze eq 1 %then %do;
24655     +      data &EM_USER_FREEZESUBSET;
24656     +        length CODEVAR $32;
24657     +        set &EM_USER_FREEZESUBSET;
24658     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
24659     +      run;
24661     +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
24662     +        by _VARIABLE_;
24663     +      run;
24665     +      %let dsid = %sysfunc(open(work.tempsubset));
24666     +      %let nobs = 0;
24667     +      %if &dsid %then %do;
24668     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
24669     +      %end;
24670     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
24672     +      data tempsubset;
24673     +        set tempsubset;
24674     +        length  binVar suffix $32;
24675     +        array binnames{&nobs} $32 _temporary_;
24676     +        retain binVar binnames;
24677     +        by _VARIABLE_;
24679     +        binVar = 'BIN_'!!strip(CODEVAR);
24680     +        binVar = ksubstr(binVar, 1, 32);
24681     +        count = 1;
24683     +        do i=1 to _N_;
24684     +           do while(binvar eq binnames(i));
24685     +              suffix = strip(put(count,best.));
24686     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
24687     +              count + 1;
24688     +           end;
24689     +        end;
24690     +        binnames(_N_)= binvar;
24691     +        output;
24692     +        drop suffix count i;
24693     +     run;
24695     +     data &EM_USER_FREEZESUBSET;
24696     +       set &EM_USER_FREEZESUBSET;
24697     +       length binVar $32;
24699     +        %let dsid = %sysfunc(open(work.tempsubset));
24700     +        %if &dsid %then %do;
24701     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24702     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
24703     +          %let obs = %sysfunc(fetch(&dsid));
24705     +          %do %while(&obs=0);
24706     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
24707     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
24709     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
24710     +            %let obs = %sysfunc(fetch(&dsid));
24711     +          %end;
24712     +        %end;
24713     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24715     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
24716     +        if binVar ne "" then do;
24717     +          _LEVEL_ = "ORDINAL";
24718     +        end;
24720     +      run;
24722     +      %let idsidexists= 0;
24723     +      %let idsid = %sysfunc(open(work._intmid));
24724     +      %if &idsid %then %do;
24725     +        %let idsidexists=1;
24726     +        %let idsid = %sysfunc(close(&idsid));
24727     +      %end;
24728     +      %if &idsidexists eq 1 %then %do;
24729     +      data _INTMID;
24730     +        set _INTMID;
24732     +        %let dsid = %sysfunc(open(work.tempsubset));
24733     +        %if &dsid %then %do;
24734     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
24735     +          %let obs = %sysfunc(fetch(&dsid));
24737     +          %do %while(&obs=0);
24738     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
24739     +            if variable = "&codevar" then delete;
24740     +            %let obs = %sysfunc(fetch(&dsid));
24741     +          %end;
24742     +        %end;
24743     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
24744     +      run;
24745     +      %end;
24747     +      proc datasets library=work nolist;
24748     +        delete tempsubset;
24749     +      run;
24750     +      quit;
24752     +    %end;
24754     +%mend EM_PRE_BINNING;
24756     +%macro EM_IMPORT_BINNING(binningCode);
24759     +   data tempintimport;
24760     +     set &EM_USER_IMPORTSUBSET;
24761     +     if binflag = 1;
24762     +   run;
24764     +   %let idsid = %sysfunc(open(work.tempintimport));
24765     +   %if &idsid %then %do;
24766     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
24767     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
24768     +   %end;
24769     +   %else %do;
24770     +     %let nvars = 0;
24771     +     %let nobs = 0;
24772     +   %end;
24773     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
24775     +   proc datasets library=work nolist;
24776     +     delete tempintimport;
24777     +   run;
24778     +   quit;
24780     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
24782     +      filename X "&binningCode";
24783     +      data _null_;
24784     +        FILE X MOD;
24785     +        %let bin_variables=;
24786     +        %let quote_bin_variables = ;
24787     +        %let choice = binflag = 1;
24788     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
24789     +        %if &dsid %then %do;
24790     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
24791     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
24792     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
24793     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note , NOQUOTE));
24795     +           put "&EM_CODEBAR;";
24796     +           put " &note; ";
24797     +           put "&EM_CODEBAR;";
24799     +           /* retrieve value for first obs */
24800     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
24801     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
24802     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
24804     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
24805     +           %let i = 1;
24806     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
24807     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
24808     +           %end;
24809     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
24810     +           put " ";
24811     +           put "if &oldname eq . then &binvalue = .;";
24813     +           /* cycle through special codes if they exist */
24814     +           %let index2 = %index(&oldname, SV_);
24815     +           %if &index2 gt 0 %then %do;
24816     +             %let choice = CODEVAR ="&oldname";
24817     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
24818     +             %if &cdsid %then %do;
24819     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
24820     +                %let cobs = %sysfunc(fetch(&cdsid));
24821     +                %do %while(&cobs=0);
24822     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
24823     +                    put "else if &oldname eq &code then &binvalue = &code;";
24824     +                   %let cobs = %sysfunc(fetch(&cdsid));
24825     +                %end;
24826     +             %end;
24827     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
24828     +           %end;
24829     +           put "else ";
24830     +           %if "&value" eq "." %then %do;
24831     +             put " &binvalue=&i;";
24832     +           %end;
24833     +           %else %do;
24834     +             put "  if &oldname < &value then &binvalue=&i;";
24835     +           %end;
24837     +           %let i= %eval(&i+1);
24839     +           %let obs = %sysfunc(fetch(&dsid));
24840     +           %do %while(&obs=0);
24841     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
24842     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
24843     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
24845     +              %if "&oldname" ne "&namevalue" %then %do;
24847     +                /* if variable has been re-coded for special codes, must include these values as well */
24848     +                put;
24849     +                put "if &namevalue eq . then &binvalue = .;";
24851     +                %let i=1;
24852     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
24853     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
24854     +                %end;
24855     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
24857     +                /* cycle through special codes if they exist */
24858     +                %let index2 = %index(&namevalue, SV_);
24859     +                %if &index2 gt 0 %then %do;
24860     +                  %let choice = CODEVAR ="&namevalue";
24861     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
24862     +                  %if &cdsid %then %do;
24863     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
24864     +                     %let cobs = %sysfunc(fetch(&cdsid));
24865     +                     %do %while(&cobs=0);
24866     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
24867     +                       put "else if &namevalue eq &code then &binvalue = &code;";
24868     +                       %let cobs = %sysfunc(fetch(&cdsid));
24869     +                     %end;
24870     +                  %end;
24871     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
24872     +                %end;
24873     +                put "else ";
24874     +                %if "&value" ne "." %then %do;
24875     +                  put "  if &namevalue < &value then &binvalue=&i;";
24876     +                %end;
24877     +                %else %do;
24878     +                  put " &binvalue=&i;";
24879     +                %end;
24881     +              %end;
24882     +              %else %do;
24883     +                put "else ";
24884     +                %if "&value" ne "." %then %do;
24885     +                  put "  if &namevalue < &value then &binvalue=&i;";
24886     +                %end;
24887     +                %else %do;
24888     +                  put "  &binvalue=&i;";
24889     +                %end;
24890     +              %end;
24891     +              %let i = %eval(&i + 1);
24892     +              %let obs = %sysfunc(fetch(&dsid));
24893     +              %let oldname = &namevalue;
24894     +              %let oldbinvalue = &binvalue;
24895     +           %end;
24896     +        %end;
24897     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
24899     +      run;
24900     +      filename X;
24901     +      /* generate BINMAPPINGS dataset */
24902     +      data TEMPBINMAPPINGS;
24903     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
24905     +        %let choice = binflag = 1;
24906     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
24907     +        %if &dsid %then %do;
24908     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
24909     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
24910     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
24911     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
24912     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
24914     +           /* retrieve information from first obs */
24915     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
24916     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
24917     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
24918     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
24919     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
24920     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
24921     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
24922     +           %let i = 1;
24924     +           NAME = "&OLDCODEVAR";
24925     +           BIN_NAME = "&OLDBINVAR";
24926     +           GRP_NAME = "&OLDGRPVAR";
24927     +           BIN = "&i";
24928     +           GRP = "&oldgrpvalue";
24929     +           LB = . ;
24930     +           UB = &oldvalue;
24931     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
24932     +           DISPLAY_VAR = "&oldvar";
24933     +           output;
24935     +           %let i = 2;
24936     +           %let obs = %sysfunc(fetch(&dsid));
24937     +           %do %while(&obs=0);
24938     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
24939     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
24940     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
24941     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
24942     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
24943     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
24945     +             %if "&oldvar" ne "&var" %then %do;
24946     +              %let i = 1;
24947     +               %let oldvalue = .;
24948     +             %end;
24950     +             NAME = "&CODEVAR";
24951     +             BIN_NAME = "&BINVAR";
24952     +             GRP_NAME = "&GRPVAR";
24953     +             BIN = "&i";
24954     +             GRP = "&group";
24955     +             LB = &oldvalue ;
24956     +             UB = &value;
24957     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
24958     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
24959     +             %end;
24960     +             %else %do;
24961     +               %if "&oldvalue" eq "." %then %do;
24962     +                 EM_BIN_LABEL = "&var < &value" ;
24963     +               %end;
24964     +               %if "&value" eq "." %then %do;
24965     +                 EM_BIN_LABEL = "&oldvalue >= &var";
24966     +               %end;
24967     +             %end;
24968     +             DISPLAY_VAR = "&var";
24969     +             output;
24971     +             %let oldvar = &var;
24972     +             %let oldcodevar = &codevar;
24973     +             %let oldbinvar = &binvar;
24974     +             %let oldgrpvar = &grpvar;
24975     +             %let oldvalue   = &value;
24976     +             %let oldgrpvalue   = &group;
24977     +             %let i = %eval(&i + 1);
24978     +             %let obs = %sysfunc(fetch(&dsid));
24979     +           %end;
24980     +        %end;
24981     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
24982     +      run;
24984     +      data &EM_USER_BINMAPPINGS;
24985     +        set &EM_USER_BINMAPPINGS tempBinMappings;
24986     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
24987     +      run;
24989     +      /* update importsubset with bin values instead of raw values */
24990     +      data &EM_USER_IMPORTSUBSET;
24991     +        set &EM_USER_IMPORTSUBSET;
24993     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
24994     +        %if &dsid %then %do;
24995     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
24996     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
24997     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
24998     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
24999     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
25000     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
25002     +          %let oldvar = ;
25003     +          %let obs = %sysfunc(fetch(&dsid));
25004     +          %do %while(&obs=0);
25005     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
25006     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
25007     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
25008     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
25009     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
25010     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
25012     +            %if "&oldvar" eq "&displayvar" %then %do;
25013     +              else
25014     +            %end;
25015     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
25016     +               _SPLIT_VALUE_ = "&bin";
25017     +            end;
25018     +            %let oldvar = &displayvar;
25019     +            %let obs = %sysfunc(fetch(&dsid));
25020     +          %end;
25021     +        %end;
25022     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
25023     +      run;
25025     +      proc sort data=&EM_USER_IMPORTSUBSET;
25026     +        by _VARIABLE_ _SPLIT_VALUE_;
25027     +      run;
25029     +      proc datasets library=work nolist;
25030     +        delete tempBinMappings;
25031     +      run;
25032     +      quit;
25033     +  %end;
25034     +%mend EM_IMPORT_BINNING;
25036     +%macro EM_FREEZE_BINNING(binningCode);
25038     +   data tempintfreeze;
25039     +     set &EM_USER_FREEZESUBSET;
25040     +     if binflag = 1;
25041     +   run;
25043     +   %let idsid = %sysfunc(open(work.tempintfreeze));
25044     +   %if &idsid %then %do;
25045     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
25046     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
25047     +   %end;
25048     +   %else %do;
25049     +     %let nvars = 0;
25050     +     %let nobs = 0;
25051     +   %end;
25052     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
25054     +   proc datasets library=work nolist;
25055     +     delete tempintimport;
25056     +   run;
25057     +   quit;
25059     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
25061     +      filename X "&binningCode";
25062     +      data _null_;
25063     +        FILE X MOD;
25065     +        %let bin_variables=.;
25066     +        %let quote_bin_variables=.;
25067     +        %let freeze_variables=;
25068     +        %let choice = binflag = 1;
25069     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
25070     +        %if &dsid %then %do;
25071     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
25072     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
25073     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
25074     +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
25076     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note , NOQUOTE));
25077     +           put "&EM_CODEBAR;";
25078     +           put "&note;";
25079     +           put "&EM_CODEBAR;";
25081     +           /* retrieve value for first obs */
25082     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
25083     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
25084     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
25085     +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
25087     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
25088     +           %let i = 1;
25089     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
25090     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
25091     +           %end;
25092     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
25093     +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
25095     +           put " ";
25096     +           put "if &oldname eq . then &binvalue = .;";
25098     +           /* cycle through special codes if they exist */
25099     +           %let index2 = %index(&oldname, SV_);
25100     +           %if &index2 gt 0 %then %do;
25101     +             %let choice = CODEVAR ="&oldname";
25102     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
25103     +             %if &cdsid %then %do;
25104     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
25105     +                %let cobs = %sysfunc(fetch(&cdsid));
25106     +                %do %while(&cobs=0);
25107     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
25108     +                    put "else if &oldname eq &code then &binvalue = &code;";
25109     +                   %let cobs = %sysfunc(fetch(&cdsid));
25110     +                %end;
25111     +             %end;
25112     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
25113     +           %end;
25114     +           put "else ";
25115     +           %if "&value" eq "." %then %do;
25116     +             put " &binvalue=&i;";
25117     +           %end;
25118     +           %else %do;
25119     +             put "  if &oldname < &value then &binvalue=&i;";
25120     +           %end;
25122     +           %let i= %eval(&i+1);
25124     +           %let obs = %sysfunc(fetch(&dsid));
25125     +           %do %while(&obs=0);
25126     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
25127     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
25128     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
25129     +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
25131     +              %if "&oldname" ne "&namevalue" %then %do;
25133     +                /* if variable has been re-coded for special codes, must include these values as well */
25134     +                put;
25135     +                put "if &namevalue eq . then &binvalue = .;";
25137     +                %let i=1;
25138     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
25139     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
25140     +                %end;
25141     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
25142     +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
25144     +                /* cycle through special codes if they exist */
25145     +                %let index2 = %index(&namevalue, SV_);
25146     +                %if &index2 gt 0 %then %do;
25147     +                  %let choice = CODEVAR ="&namevalue";
25148     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
25149     +                  %if &cdsid %then %do;
25150     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
25151     +                     %let cobs = %sysfunc(fetch(&cdsid));
25152     +                     %do %while(&cobs=0);
25153     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
25154     +                       put "else if &namevalue eq &code then &binvalue = &code;";
25155     +                       %let cobs = %sysfunc(fetch(&cdsid));
25156     +                     %end;
25157     +                  %end;
25158     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
25159     +                %end;
25160     +                put "else ";
25161     +                %if "&value" ne "." %then %do;
25162     +                  put "  if &namevalue < &value then &binvalue=&i;";
25163     +                %end;
25164     +                %else %do;
25165     +                  put " &binvalue=&i;";
25166     +                %end;
25168     +              %end;
25169     +              %else %do;
25170     +                put "else ";
25171     +                %if "&value" ne "." %then %do;
25172     +                  put "  if &namevalue < &value then &binvalue=&i;";
25173     +                %end;
25174     +                %else %do;
25175     +                  put " &binvalue=&i;";
25176     +                %end;
25177     +              %end;
25178     +              %let i = %eval(&i + 1);
25179     +              %let obs = %sysfunc(fetch(&dsid));
25180     +              %let oldname = &namevalue;
25181     +              %let oldbinvalue = &binvalue;
25182     +           %end;
25183     +        %end;
25184     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
25186     +      run;
25187     +      filename X;
25188     +      /* generate BINMAPPINGS dataset */
25189     +      data TEMPBINMAPPINGS;
25190     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
25192     +        %let choice = binflag = 1;
25193     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
25194     +        %if &dsid %then %do;
25195     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
25196     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
25197     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
25198     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
25199     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
25201     +           /* retrieve information from first obs */
25202     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
25203     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
25204     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
25205     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
25206     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
25207     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
25208     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
25209     +           %let i = 1;
25211     +           NAME = "&OLDCODEVAR";
25212     +           BIN_NAME = "&OLDBINVAR";
25213     +           GRP_NAME = "&OLDGRPVAR";
25214     +           BIN = "&i";
25215     +           GRP = "&oldgrpvalue";
25216     +           LB = . ;
25217     +           UB = &oldvalue;
25218     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
25219     +           DISPLAY_VAR = "&oldvar";
25220     +           output;
25222     +           %let i = 2;
25223     +           %let obs = %sysfunc(fetch(&dsid));
25224     +           %do %while(&obs=0);
25225     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
25226     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
25227     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
25228     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
25229     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
25230     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
25232     +             %if "&oldvar" ne "&var" %then %do;
25234     +               %let i = 1;
25235     +               %let oldvalue = .;
25236     +             %end;
25238     +             NAME = "&CODEVAR";
25239     +             BIN_NAME = "&BINVAR";
25240     +             GRP_NAME = "&GRPVAR";
25241     +             BIN = "&i";
25242     +             GRP = "&group";
25243     +             LB = &oldvalue ;
25244     +             UB = &value;
25245     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
25246     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
25247     +             %end;
25248     +             %else %do;
25249     +               %if "&oldvalue" eq "." %then %do;
25250     +                 EM_BIN_LABEL = "&var < &value" ;
25251     +               %end;
25252     +               %if "&value" eq "." %then %do;
25253     +                 EM_BIN_LABEL = "&oldvalue >= &var";
25254     +               %end;
25255     +             %end;
25256     +             DISPLAY_VAR = "&var";
25257     +             output;
25259     +             %let oldvar = &var;
25260     +             %let oldcodevar = &codevar;
25261     +             %let oldbinvar = &binvar;
25262     +             %let oldgrpvar = &grpvar;
25263     +             %let oldvalue   = &value;
25264     +             %let oldgrpvalue = &group;
25265     +             %let i = %eval(&i + 1);
25266     +             %let obs = %sysfunc(fetch(&dsid));
25267     +           %end;
25268     +        %end;
25270     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
25271     +      run;
25273     +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings -- prevents duplicate entries */
25274     +      data &EM_USER_BINMAPPINGS;
25275     +        set &EM_USER_BINMAPPINGS;
25276     +        if NAME in (&FREEZE_VARIABLES) then delete;
25277     +      run;
25279     +      data &EM_USER_BINMAPPINGS;
25280     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
25282     +        set &EM_USER_BINMAPPINGS tempBinMappings;
25283     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
25284     +      run;
25286     +      /* update freezesubset with bin values instead of raw values */
25287     +      data &EM_USER_FREEZESUBSET;
25288     +        set &EM_USER_FREEZESUBSET;
25290     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
25291     +        %if &dsid %then %do;
25292     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
25293     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
25294     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
25295     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
25296     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
25297     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
25299     +          %let oldvar = ;
25300     +          %let obs = %sysfunc(fetch(&dsid));
25301     +          %do %while(&obs=0);
25302     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
25303     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
25304     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
25305     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
25306     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
25307     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
25309     +            %if "&oldvar" eq "&displayvar" %then %do;
25310     +              else
25311     +            %end;
25312     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
25313     +               _SPLIT_VALUE_ = "&bin";
25314     +            end;
25315     +            %let oldvar =&displayvar;
25316     +            %let obs = %sysfunc(fetch(&dsid));
25317     +          %end;
25318     +        %end;
25319     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
25320     +      run;
25322     +      proc sort data=&EM_USER_FREEZESUBSET;
25323     +        by _VARIABLE_ _SPLIT_VALUE_;
25324     +      run;
25326     +      proc datasets library=work nolist;
25327     +        delete tempBinMappings;
25328     +      run;
25329     +      quit;
25330     +   %end;
25331     +%mend EM_FREEZE_BINNING;
25333     +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
25336     +/* initialize new bucket_binning macro */
25337     +filename temp catalog 'sashelp.emapps.bucket_binning.source';
25338     +%include temp;
25339     +filename temp;
25341     +/* create fileref for generation of binningCode */
25342     +filename X "&binningCode";
25344     +/* determine if there are inputs to be binned */
25345     +%let numbinvars = 0;
25346     +%let intdsid = %sysfunc(open(work._intmid));
25347     +%if &intdsid %then %do;
25348     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
25349     +%end;
25350     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
25351     +%if &numbinvars > 0 %then %do;
25354     +/* get data in format needed for quantile_binning macro */
25355     +data work.vartable;
25356     +  set work._intmid;
25357     +  level = "INTERVAL";
25358     +  role  = "INPUT";
25359     +  rename variable=name;
25360     +run;
25362     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
25363     +%if %EM_FREQ ne %then %do;
25364     +   data work.freq;
25365     +     name="%EM_FREQ";
25366     +     role="FREQ";
25367     +   run;
25369     +   data work.vartable;
25370     +     set work.vartable work.freq;
25371     +   run;
25372     +%end;
25374     +/* perform bucket binning of data */
25375     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
25376     +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
25378     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
25379     +%end;
25380     +%else %do;
25381     +  /* initialize binmappings table */
25382     +  data &EM_USER_BINMAPPINGS;
25383     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
25384     +  run;
25386     +  data _null_;
25387     +    FILE X;
25389     +    put "&EM_CODEBAR;";
25390     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
25391     +    put "* &note;";
25392     +    put "&EM_CODEBAR;";
25393     +  run;
25395     +%end;
25397     +/* assign display_var values to binmappings table as well as initial group values */
25398     +data &EM_USER_BINMAPPINGS;
25399     +  set &EM_USER_BINMAPPINGS;
25400     +  length display_var $32 grp $8;
25401     +  display_var = name;
25403     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
25404     +    GRP = BIN + 1;
25405     +  %end;
25406     +  %else %do;
25407     +    GRP = BIN;
25408     +  %end;
25409     +run;
25411     +/* de-assign fileref */
25412     +filename X;
25414     +    /* append to binning code those values that were included in the importSubset data */
25415     +    %if &useImport eq 1 %then %do;
25416     +      %EM_IMPORT_BINNING(&binningcode);
25417     +    %end;
25419     +    /* append to binning code those values that were included in the freezeSubset data */
25420     +    %if &useFreeze eq 1 %then %do;
25421     +      %EM_FREEZE_BINNING(&binningcode);
25422     +    %end;
25424     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
25425     +     by NAME;
25426     +     run;
25428     +     /* create grouping for missing level */
25429     +    data tempmissvalues;
25430     +    run;
25432     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
25433     +       data tempmissvalues;
25434     +         %if &useImport eq 1 %then %do;
25435     +           merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
25436     +         %end;
25437     +         %if &useFreeze eq 1 %then %do;
25438     +           merge sortedmapping &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
25439     +         %end;
25440     +         %else %do;
25441     +           set sortedmapping;
25442     +         %end;
25443     +         GRP="1";
25444     +         bin="Missing";
25445     +         _split_value_ = "Missing";
25446     +         %if &useImport eq 1 %then %do;
25447     +            if _a then delete;
25448     +         %end;
25449     +         %if &useFreeze eq 1 %then %do;
25450     +            if _b then delete;
25451     +         %end;
25453     +       run;
25454     +    %end;
25456     +    /* create binData from binningCode */
25457     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
25458     +      by NAME;
25459     +    run;
25461     +    filename X "&binningCode";
25462     +    data &bindata;
25463     +      set &input;
25464     +      %inc X;
25465     +    run;
25467     +    filename X;
25469     +    /* create splitvals dataset */
25470     +    data tempsplitvals;
25471     +      set &EM_USER_BINMAPPINGS
25472     +        %let tdsid = %sysfunc(open(work.tempmissvalues));
25473     +        %if &tdsid %then %do;
25474     +          tempmissvalues
25475     +        %end;
25476     +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
25477     +      ;
25478     +      length newgroup _group_ 8 _level_ $8;
25479     +      newgroup =.;
25480     +      _LEVEL_ = 'ORDINAL';
25481     +      _Group_ = grp;
25482     +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
25483     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
25484     +    run;
25486     +    data tempsplitvals;
25487     +      set tempsplitvals;
25488     +      _order_ = _N_;
25489     +    run;
25491     +    /* determine if EM_USER_SPLITVALS already exists */
25492     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
25493     +    %if &sdsid > 0 %then %do;
25494     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
25495     +      %if &nvars > 0 %then %do;
25496     +        proc sql;
25497     +          reset noprint;
25498     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
25499     +        quit;
25500     +      %end;
25501     +      %else %let nobs=0;
25502     +    %end;
25503     +    %else %do;
25504     +       %let nobs=0;
25505     +       %let nvars=0;
25506     +    %end;
25507     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
25509     +    /* if useIMport=1 also include import definitions here as well */
25510     +    %if &useImport eq 1 %then %do;
25511     +      data tempImport;
25512     +        set &EM_USER_IMPORTSUBSET;
25513     +        _variable_ = binVar;
25514     +      run;
25515     +    %end;
25517     +    /* if useFreeze=1 also include import definitions here as well */
25518     +    %if &useFreeze eq 1 %then %do;
25519     +      data tempFreeze;
25520     +        length display_var $32;
25521     +        set &EM_USER_FREEZESUBSET;
25522     +        display_var = _variable_;
25523     +        _variable_ = binVar;
25524     +      run;
25525     +    %end;
25528     +    data &EM_USER_SPLITVALS;
25529     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
25530     +        set &EM_USER_SPLITVALS tempsplitvals
25531     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
25532     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
25533     +        %end;
25534     +        %if &useFreeze eq 1 %then %do;
25535     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
25536     +        %end;
25537     +        ;
25538     +      %end;
25539     +      %else %do;
25540     +        set tempsplitvals
25541     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
25542     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
25543     +        %end;
25544     +        %if &useFreeze eq 1 %then %do;
25545     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
25546     +        %end;
25547     +        ;
25548     +      %end;
25549     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
25550     +    run;
25552     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
25553     +    data tempvariableset;
25554     +      set &EM_DATA_VARIABLESET;
25555     +      where TYPE = 'C';
25556     +    run;
25558     +    /* add all interval vars that aren't special codes to the intervalvar macro
25559     +    %let dsid = %sysfunc(open(work.tempvariableset));
25560     +    %if &dsid %then %do;
25561     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
25562     +      %let obs = %sysfunc(fetch(&dsid));
25563     +      %do %while(&obs=0);
25564     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
25565     +        %let classvars = &classvars &varname;
25566     +        %let qclassvars = &qclassvars "&varname";
25567     +        %let obs = %sysfunc(fetch(&dsid));
25568     +      %end;
25569     +    %end;
25570     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
25571     +    */
25572     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
25574     +    %if %classvars ne %then %do;
25575     +      proc dmdb data =&bindata classout=_classout nonorm;
25576     +        class %classvars;
25577     +      run;
25579     +      proc dmdb data=&bindata classout=_classout2;
25580     +       class %classvars;
25581     +      run;
25583     +      proc sort data=_classout; by NAME CRAW; run;
25584     +      proc sort data=_classout2; by NAME CRAW; run;
25586     +      data _classout;
25587     +        length _variable_ $32;
25588     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
25589     +        _split_value_ = trim(left(_split_value_));
25590     +        LEVEL = trim(left(LEVEL));
25591     +        by NAME CRAW;
25592     +       _variable_ = NAME;
25593     +      run;
25595     +      proc sort data=_classout; by _variable_ _split_value_; run;
25596     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
25598     +      data &EM_USER_SPLITVALS;
25599     +        length _norm_level_ $200 _split_value_ $200;
25600     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
25601     +        by _variable_ _split_value_;
25602     +        LEVEL = trim(left(LEVEL));
25603     +        _norm_level_ = trim(left(_norm_level_));
25604     +        _split_value_ = trim(left(_split_value_));
25605     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
25606     +        drop NAME FREQUENCY TYPE CRAW NRAW;
25607     +      run;
25609     +      proc datasets library=work nolist;
25610     +        delete _classout _classout2;
25611     +      run;
25612     +      quit;
25613     +    %end;
25614     +    data &EM_USER_SPLITVALS;
25615     +      set &EM_USER_SPLITVALS;
25616     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
25617     +    run;
25619     +    proc sort data=&EM_USER_SPLITVALS;
25620     +      by DISPLAY_VAR _Group_;
25621     +    run;
25623     +   proc datasets library=work nolist;
25624     +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals sortedmapping tempmissvalues
25625     +      %if &useImport eq 1 %then %do;
25626     +        tempImport
25627     +      %end;
25628     +      %if &useFreeze eq 1 %then %do;
25629     +        tempFreeze
25630     +      %end;
25631     +     ;
25632     +   run;
25633     +   quit;
25635     +%mend;
25637     +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
25639     +/* initialize new quantile_binning macro */
25640     +filename temp catalog 'sashelp.emapps.quantile_binning.source';
25641     +%include temp;
25642     +filename temp;
25644     +/* generate fileref for quantile_binning macro */
25645     +filename X "&binningCode";
25647     +/* determine if there are inputs to be binned */
25648     +%let numbinvars = 0;
25649     +%let intdsid = %sysfunc(open(work._intmid));
25650     +%if &intdsid %then %do;
25651     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
25652     +%end;
25653     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
25654     +%if &numbinvars > 0 %then %do;
25656     +/* get data in format needed for quantile_binning macro */
25657     +data work.vartable;
25658     +  set work._intmid;
25659     +  level = "INTERVAL";
25660     +  role  = "INPUT";
25661     +  rename variable=name;
25662     +run;
25664     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
25665     +%if %EM_FREQ ne %then %do;
25666     +   data work.freq;
25667     +     name="%EM_FREQ";
25668     +     role="FREQ";
25669     +   run;
25671     +   data work.vartable;
25672     +     set work.vartable work.freq;
25673     +   run;
25674     +%end;
25677     +/* perform quantile binning of data */
25678     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
25679     +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
25681     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
25682     +%end;
25683     +%else %do;
25684     +  /* initialize binmappings table */
25685     +  data &EM_USER_BINMAPPINGS;
25686     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
25687     +  run;
25689     +  data _null_;
25690     +    FILE X;
25692     +    put "&EM_CODEBAR;";
25693     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
25694     +    put "* &note;";
25695     +    put "&EM_CODEBAR;";
25696     +  run;
25698     +%end;
25700     +/* assign display_var values to binmappings table as well as initial group values */
25701     +data &EM_USER_BINMAPPINGS;
25702     +  set &EM_USER_BINMAPPINGS;
25703     +  length display_var $32 grp $8;
25704     +  display_var = name;
25706     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
25707     +    GRP = BIN + 1;
25708     +  %end;
25709     +  %else %do;
25710     +    GRP = BIN;
25711     +  %end;
25712     +run;
25714     +/* de-assign fileref */
25715     +filename X;
25717     +    /* append to binning code those values that were included in the importSubset data */
25718     +    %if &useImport eq 1 %then %do;
25719     +      %EM_IMPORT_BINNING(&binningcode);
25720     +    %end;
25722     +    /* append to binning code those values that were included in the freezeSubset data */
25723     +    %if &useFreeze eq 1 %then %do;
25724     +      %EM_FREEZE_BINNING(&binningcode);
25725     +    %end;
25727     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
25728     +      by NAME;
25729     +    run;
25731     +    /* create grouping for missing level */
25732     +    data tempmissvalues;
25733     +    run;
25735     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
25736     +       data tempmissvalues;
25737     +         %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
25738     +           merge sortedmapping
25739     +           %if &useImport eq 1 %then %do;
25740     +              &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
25741     +           %end;
25742     +           %if &useFreeze eq 1 %then %do;
25743     +             &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
25744     +           %end;
25745     +           ;
25746     +         %end;
25747     +         %else %do;
25748     +           set sortedmapping;
25749     +         %end;
25750     +         GRP="1";
25751     +         bin="Missing";
25752     +         _split_value_ = "Missing";
25753     +         %if &useImport eq 1 %then %do;
25754     +            if _a then delete;
25755     +         %end;
25756     +         %if &useFreeze eq 1 %then %do;
25757     +            if _b then delete;
25758     +         %end;
25760     +       run;
25761     +    %end;
25764     +    /* create binData from binningCode */
25765     +    filename X "&binningCode";
25767     +    data &bindata;
25768     +      set &input;
25769     +      %inc X;
25770     +    run;
25772     +    filename X;
25774     +    /* create splitvals dataset */
25775     +    data tempsplitvals;
25776     +      set &EM_USER_BINMAPPINGS tempmissvalues;
25777     +      length newgroup _group_ _order_ 8 _level_ $8;
25778     +      newgroup =.;
25779     +      _LEVEL_ = 'ORDINAL';
25780     +      _Group_ = grp;
25781     +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
25782     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
25783     +    run;
25785     +    data tempsplitvals;
25786     +      set tempsplitvals;
25787     +      _order_ = _N_;
25788     +    run;
25790     +    /* determine if EM_USER_SPLITVALS already exists */
25791     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
25792     +    %if &sdsid > 0 %then %do;
25793     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
25794     +      %if &nvars > 0 %then %do;
25795     +        proc sql;
25796     +          reset noprint;
25797     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
25798     +        quit;
25799     +      %end;
25800     +      %else %let nobs=0;
25801     +    %end;
25802     +    %else %do;
25803     +       %let nobs=0;
25804     +       %let nvars=0;
25805     +    %end;
25806     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
25808     +    /* if useIMport=1 also include import definitions here as well */
25809     +    %if &useImport eq 1 %then %do;
25810     +      data tempImport;
25811     +        set &EM_USER_IMPORTSUBSET;
25812     +        _variable_ = binVar;
25813     +      run;
25814     +    %end;
25816     +    /* if useFreeze=1 also include frozen definitions here as well */
25817     +    %if &useFreeze eq 1 %then %do;
25818     +      data tempFreeze;
25819     +        length display_var $32;
25820     +        set &EM_USER_FreezeSUBSET;
25821     +        display_var = _variable_;
25822     +        _variable_ = binVar;
25823     +      run;
25824     +    %end;
25826     +    data &EM_USER_SPLITVALS;
25827     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
25828     +        set &EM_USER_SPLITVALS tempsplitvals
25829     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
25830     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
25831     +        %end;
25832     +        %if &useFreeze eq 1 %then %do;
25833     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
25834     +        %end;
25835     +        ;
25836     +      %end;
25837     +      %else %do;
25838     +        set tempsplitvals
25839     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
25840     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
25841     +        %end;
25842     +        %if &useFreeze eq 1 %then %do;
25843     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
25844     +        %end;
25845     +        ;
25846     +      %end;
25847     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
25848     +    run;
25850     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
25851     +    data tempvariableset;
25852     +      set &EM_DATA_VARIABLESET;
25853     +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
25854     +    run;
25856     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
25858     +    /* add all interval vars that aren't special codes to the intervalvar macro
25859     +    %let dsid = %sysfunc(open(work.tempvariableset));
25860     +    %if &dsid %then %do;
25861     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
25862     +      %let obs = %sysfunc(fetch(&dsid));
25863     +      %do %while(&obs=0);
25864     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
25865     +        %let classvars = &classvars &varname;
25866     +        %let qclassvars = &qclassvars "&varname";
25867     +        %let obs = %sysfunc(fetch(&dsid));
25868     +      %end;
25869     +    %end;
25870     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
25871     +*/
25872     +    %if %classvars ne %then %do;
25873     +      proc dmdb data =&bindata classout=_classout nonorm;
25874     +        class %classvars;
25875     +      run;
25877     +      proc dmdb data=&bindata classout=_classout2;
25878     +       class %classvars;
25879     +      run;
25881     +      proc sort data=_classout; by NAME CRAW; run;
25882     +      proc sort data=_classout2; by NAME CRAW; run;
25884     +      data _classout;
25885     +        length _variable_ $32;
25886     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
25887     +        by NAME CRAW;
25888     +       _variable_ = NAME;
25889     +      run;
25891     +      proc sort data=_classout; by _variable_ _split_value_; run;
25892     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
25894     +      data &EM_USER_SPLITVALS;
25895     +        length _norm_level_ $200 _split_value_ $200;
25896     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
25897     +        by _variable_ _split_value_;
25898     +        LEVEL = trim(left(LEVEL));
25899     +        _split_value_ = trim(left(_split_value_));
25900     +        _norm_level_ = trim(left(_norm_level_));
25901     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
25902     +        drop NAME FREQUENCY TYPE CRAW NRAW;
25903     +      run;
25905     +      proc datasets library=work nolist;
25906     +        delete _classout _classout2;
25907     +      run;
25908     +      quit;
25909     +    %end;
25911     +    data &EM_USER_SPLITVALS;
25912     +      set &EM_USER_SPLITVALS;
25913     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
25914     +    run;
25917     +    proc sort data=&EM_USER_SPLITVALS;
25918     +      by DISPLAY_VAR _Group_;
25919     +    run;
25921     +    proc datasets library=work nolist;
25922     +      delete sortedmapping tempsplitvals tempmissvalues
25923     +      %if &useImport eq 1 %then %do;
25924     +        tempImport
25925     +      %end;
25926     +      %if &useFreeze eq 1 %then %do;
25927     +        tempFreeze
25928     +      %end;
25929     +      ;
25930     +    run;
25931     +    quit;
25932     +/*
25933     +%end;
25934     +%else %do;
25935     +    data &bindata;
25936     +      set &input;
25937     +    run;
25938     +%end;
25939     +*/
25940     +%mend EM_QUANTILE_BINNING;
25942     +%macro EM_ORDVARS_GROUP;
25944     +   /* retrieve all ordinal variables from the incoming dataset */
25945     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
25946     +     by NAME;
25947     +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
25948     +   run;
25950     +   /* add all vars marked as interval that are actually class vars to this data */
25951     +   %let nobs = 0;
25952     +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
25953     +   %if &dsid %then %do;
25954     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
25955     +     %if &nobs gt 0 %then %do;
25957     +     data tempvars;
25958     +       set &EM_DATA_VARIABLESET;
25959     +       if NAME in (
25960     +         %let obs = %sysfunc(fetch(&dsid));
25961     +         %do %while(&obs=0);
25962     +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
25963     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
25964     +           "&varname"
25965     +           %let obs = %sysfunc(fetch(&dsid));
25966     +         %end;
25967     +        );
25968     +     run;
25969     +     data tempvariableset;
25970     +       set tempvariableset tempvars;
25971     +     run;
25972     +     %end;
25973     +   %end;
25974     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
25976     +   %if &useImport eq 1 %then %do;
25977     +     /* remove all variables from tempvariableset that are included in the importsubset */
25978     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
25979     +       by _VARIABLE_ ;
25980     +     run;
25981     +     proc sort data=tempvariableset; by NAME; run;
25983     +     data tempvariableset;
25984     +       merge tempimport(in=_a) tempvariableset(in=_b);
25985     +       by NAME;
25986     +       if ^_a then output;
25987     +     run;
25988     +   %end;
25990     +   %if &useFreeze eq 1 %then %do;
25991     +     /* remove all variables from tempvariableset that are included in the freezesubset */
25992     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
25993     +       by _VARIABLE_ ;
25994     +     run;
25995     +     proc sort data=tempvariableset; by NAME; run;
25997     +     data tempvariableset;
25998     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
25999     +       by NAME;
26000     +       if ^_a then output;
26001     +     run;
26002     +   %end;
26004     +   /* get dataset of distinct values for the ordinal variable */
26005     +   %let nobs = 0;
26006     +   %let dsid = %sysfunc(open(WORK.tempvariableset));
26007     +   %if &dsid %then %do;
26008     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
26009     +     %if &nobs gt 0 %then %do;
26010     +         %let obs = %sysfunc(fetch(&dsid));
26011     +         %do %while(&obs=0);
26012     +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
26013     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
26014     +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
26015     +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
26016     +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
26017     +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
26018     +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
26019     +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
26020     +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
26022     +           data temp;
26023     +             set &EM_USER_BINDATA(keep=&varname);
26024     +             %if &input_fmt ne %then %do;
26025     +               %dmnormcp(put(&varname, &input_fmt), _norm);
26026     +             %end;
26027     +             %else %do;
26028     +               %dmnormcp(&varname, _norm);
26029     +             %end;
26030     +             keep &varname _norm;
26031     +           run;
26033     +          proc dmdb data=temp classout=_classout2;
26034     +           class _norm;
26035     +         run;
26036     +         proc sort data=_classout2; by LEVEL; run;
26038     +         /* re-order numeric inputs based on non-normalized values */
26039     +         %if &input_type eq N %then %do;
26040     +           proc sort data=temp nodupkey; by _norm; run;
26041     +           data varvals;
26042     +             merge temp _classout2(rename=(LEVEL=_norm));
26043     +             by _norm;
26044     +             if craw='' and _norm ne '.' then delete;
26045     +             keep &varname _norm nraw craw;
26046     +           run;
26048     +           proc sort data=varvals; by &varname; run;
26049     +         %end;
26050     +         %else %do;
26051     +           data varvals;
26052     +              set _classout2(rename=(LEVEL=_norm));
26053     +              if _norm='' then delete;
26054     +              if _norm='.' then delete;
26055     +              keep _norm;
26056     +           run;
26057     +         %end;
26058     +         data varvals;
26059     +           set varvals;
26060     +           if &varname="." then delete;
26061     +           if upcase(&varname) = "MISSING" then delete;
26062     +         run;
26064     +          /* generate Splitvals Data */
26065     +          data tempsplitvals;
26066     +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ _order_ 8 _level_ $8 _norm_level_ $200 ;
26068     +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26069     +              DISPLAY_VAR="&varname";
26070     +              _VARIABLE_ ="&varname";
26071     +              newgroup   =.;
26072     +              _group_    =1;
26073     +              _Split_Value_="Missing";
26074     +              _level_    ="ORDINAL";
26075     +              output;
26076     +              %let group=2;
26077     +            %end;
26078     +            %else %let group=1;
26080     +            %let vdsid = %sysfunc(open(WORK.VARVALS));
26081     +            %if &vdsid %then %do;
26082     +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
26083     +            /*%let group = 2;*/
26084     +            %let vobs = %sysfunc(fetch(&vdsid));
26085     +            %do %while(&vobs=0);
26086     +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))));
26088     +                DISPLAY_VAR   = "&varname";
26089     +                _variable_    = "&varname";
26090     +                newgroup      = .;
26091     +                _group_       = &group;
26092     +                _split_value_ = "&nameval";
26093     +                _level_       = 'ORDINAL';
26094     +                output;
26096     +              %let group = %eval(&group + 1);
26097     +              %let vobs = %sysfunc(fetch(&vdsid));
26098     +            %end;
26099     +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
26100     +          run;
26102     +          /* determine if EM_USER_SPLITVALS already exists */
26103     +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
26104     +          %if &sdsid > 0 %then %do;
26105     +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
26106     +            %if &nvars > 0 %then %do;
26107     +               proc sql;
26108     +                reset noprint;
26109     +                select count(*) into :nobs from &EM_USER_SPLITVALS;
26110     +               quit;
26111     +            %end;
26112     +            %else %let nobs=0;
26113     +            %end;
26114     +            %else %do;
26115     +              %let nobs=0;
26116     +              %let nvars=0;
26117     +            %end;
26118     +          %end;
26119     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
26121     +          /* if tempsplitvals doesn't exist; create empty data set */
26122     +          %let sdsid = %sysfunc(open(work.tempsplitvals));
26123     +          %if &sdsid <= 0 %then %do;
26124     +            data tempsplitvals;
26125     +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ 8 _level_ $8 ;
26126     +            run;
26127     +          %end;
26128     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
26130     +          data tempsplitvals;
26131     +            set tempsplitvals;
26132     +            _order_ = _N_;
26133     +          run;
26135     +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
26136     +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
26137     +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
26138     +          %end;
26140     +          data &EM_USER_SPLITVALS;
26141     +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
26142     +             merge &EM_USER_SPLITVALS tempsplitvals;
26143     +             by _variable_ _split_value_;
26144     +           %end;
26145     +           %else %do;
26146     +             set tempsplitvals;
26147     +           %end;
26148     +           if display_var eq "" then delete;
26149     +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
26150     +           keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_ _order_;
26151     +         run;
26153     +           %let obs = %sysfunc(fetch(&dsid));
26154     +         %end;
26155     +     %end;
26156     +   %end;
26157     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26159     +   proc sort data=&EM_USER_SPLITVALS;
26160     +      by DISPLAY_VAR _Group_;
26161     +   run;
26163     +   /* delete temporary datasets */
26164     +   proc datasets library= work nolist;
26165     +     delete tempsplitvals varvals tempvariableset tempvars
26166     +     ;
26167     +   run;
26168     +   quit;
26169     +%mend EM_ORDVARS_GROUP;
26172     +%macro EM_CLASSVARS_GROUP(groupRare);
26174     +   /* retrieve all class variables from the incoming dataset */
26175     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
26176     +     by NAME;
26177     +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
26178     +   run;
26180     +   %if &useImport eq 1 %then %do;
26181     +     /* remove all variables from tempvariableset that are included in the importsubset */
26182     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
26183     +       by _VARIABLE_ ;
26184     +     run;
26185     +     proc sort data=tempvariableset; by NAME; run;
26187     +     data tempvariableset;
26188     +       merge tempimport(in=_a) tempvariableset(in=_b);
26189     +       by NAME;
26190     +       if ^_a then output;
26191     +     run;
26192     +   %end;
26194     +   %if &useFreeze eq 1 %then %do;
26195     +     /* remove all variables from tempvariableset that are included in the freezesubset */
26196     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
26197     +       by _VARIABLE_ ;
26198     +     run;
26199     +     proc sort data=tempvariableset; by NAME; run;
26201     +     data tempvariableset;
26202     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
26203     +       by NAME;
26204     +       if ^_a then output;
26205     +     run;
26206     +   %end;
26208     +   /* run dmdb to retrieve list of all class levels and counts */
26209     +   %let dsid = %sysfunc(open(work.tempvariableset));
26210     +   %let nobs = 0;
26211     +   %if &dsid %then %do;
26212     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
26214     +   %end;
26216     +   %if &nobs gt 0 %then %do;
26217     +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
26218     +       class
26220     +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
26221     +        %let obs = %sysfunc(fetch(&dsid));
26222     +        %do %while(&obs=0);
26223     +           %let name = %sysfunc(getvarc(&dsid, &namenum));
26224     +           &name
26225     +           %let obs = %sysfunc(fetch(&dsid));
26226     +        %end;
26227     +     ;
26229     +     %if %EM_FREQ ne %then %do;
26230     +        freq %EM_FREQ;
26231     +     %end;
26232     +    run;
26233     +   %end;
26234     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26236     +   %let dsid = %sysfunc(open(work.tempclassout));
26237     +   %let nobs = 0;
26238     +   %if &dsid %then %do;
26239     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
26240     +     %let dsid = %sysfunc(close(&dsid));
26241     +   %end;
26243     +   %if &nobs gt 0 %then %do;
26244     +    data tempclassout;
26245     +       set tempclassout;
26246     +       if LEVEL='MISSING' then level='Missing';
26247     +    run;
26249     +    proc sort data=tempclassout nodupkey;
26250     +      by NAME descending FREQUENCY LEVEL;
26251     +    run;
26253     +    data tempds(keep=NAME NOBS);
26254     +      retain NOBS;
26255     +      set tempclassout;
26256     +      by NAME;
26257     +      if first.NAME then
26258     +        NOBS = frequency;
26259     +      else
26260     +        NOBS=NOBS+frequency;
26261     +      if last.name then do;
26262     +        output;
26263     +      end;
26264     +    run;
26266     +    data tempds;
26267     +      merge tempclassout
26268     +      tempds;
26269     +      by NAME;
26270     +      if ((LEVEL ne '') AND (LEVEL ne "."));
26271     +      %if &groupRare eq Y %then %do;
26272     +        PCT = 100 * (FREQUENCY/NOBS);
26273     +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
26274     +        else flag=0;
26275     +      %end;
26276     +      %else %do;
26277     +        flag = 0;
26278     +      %end;
26279     +    run;
26281     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26282     +      data tempmissvalues;
26283     +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
26285     +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
26286     +      %if &dsid %then %do;
26287     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
26288     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
26289     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
26290     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
26291     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
26292     +        %let obs = %sysfunc(fetch(&dsid));
26294     +        %do %while(&obs=0);
26295     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
26296     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
26297     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
26298     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
26300     +          NAME="&var";
26301     +          LEVEL="Missing";
26302     +          _LEVEL_="&varlvl";
26303     +          _group_ = 1;
26304     +          output;
26306     +          %let obs = %sysfunc(fetch(&dsid));
26307     +        %end;
26308     +      %end;
26309     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26310     +      run;
26311     +    %end;
26313     +    /* generate Splitvals Data */
26314     +    data tempsplitvals;
26315     +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
26317     +      set tempclassout
26318     +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26319     +         tempmissvalues
26320     +      %end;
26321     +      ;
26322     +      if ((level ne '') AND (level ne '.'));
26324     +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
26325     +     %if &dsid %then %do;
26326     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
26327     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
26328     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
26329     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
26330     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
26331     +        %let obs = %sysfunc(fetch(&dsid));
26333     +        %do %while(&obs=0);
26334     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
26335     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
26336     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
26337     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
26339     +          if NAME = "&var" then do;
26340     +            _LEVEL_ = "&varlvl";
26342     +          /* cycle through levels, assigning group values;              */
26343     +          /* flag=1 indicates to put value in "_OTHER_" group;          */
26344     +          /* flag=0 indicates that value shoudld be in group of its own */
26345     +          %let choice = ((NAME="&Var") and (FLAG=0));
26346     +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26347     +            %let group=2;
26348     +          %end;
26349     +          %else %do;
26350     +            %let group = 1;
26351     +          %end;
26352     +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
26353     +          %if &fdsid %then %do;
26355     +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
26356     +            %let fobs = %sysfunc(fetch(&Fdsid));
26357     +            %let fflag = 0;
26358     +            %do %while(&fobs=0);
26359     +              %let fflag = 1;
26360     +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
26361     +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26362     +              %let level = %nrbquote(%sysfunc(strip(&level)));
26363     +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26364     +                %if &group eq 2 %then %do;
26365     +                   if LEVEL = "&level" then _GROUP_ = &group;
26366     +                %end;
26367     +                %else %do;
26368     +                   else if LEVEL = "&level" then _GROUP_ = &group;
26369     +                %end;
26370     +              %end;
26371     +              %else %do;
26372     +                %if &group eq 1 %then %do;
26373     +                   if LEVEL = "&level" then _GROUP_ = &group;
26374     +                %end;
26375     +                %else %do;
26376     +                   else if LEVEL = "&level" then _GROUP_ = &group;
26377     +                %end;
26378     +              %end;
26380     +              %let group = %eval(&group + 1);
26381     +              %let fobs = %sysfunc(fetch(&fdsid));
26382     +            %end;
26384     +          %end;
26385     +          %if &fflag eq 1 %then %do;
26386     +            else if LEVEL ^='Missing' then _GROUP_ = &group;
26387     +          %end;
26388     +          end;
26390     +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
26391     +          %let obs = %sysfunc(fetch(&dsid));
26392     +        %end;
26393     +     %end;
26394     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26395     +     _VARIABLE_ = NAME;
26396     +     newgroup = .;
26397     +     rename NAME = DISPLAY_VAR
26398     +            LEVEL = _SPLIT_VALUE_;
26399     +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
26400     +    run;
26401     +  %end;
26402     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26404     +    /* determine if EM_USER_SPLITVALS already exists */
26405     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
26406     +    %if &sdsid > 0 %then %do;
26407     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
26408     +      %if &nvars > 0 %then %do;
26409     +        proc sql;
26410     +          reset noprint;
26411     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
26412     +        quit;
26413     +      %end;
26414     +      %else %let nobs=0;
26415     +    %end;
26416     +    %else %do;
26417     +       %let nobs=0;
26418     +       %let nvars=0;
26419     +    %end;
26420     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
26422     +   /* if tempsplitvals doesn't exist; create empty data set */
26423     +    %let sdsid = %sysfunc(open(work.tempsplitvals));
26424     +    %if &sdsid <= 0 %then %do;
26425     +      data tempsplitvals;
26426     +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
26427     +      run;
26428     +    %end;
26429     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
26431     +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
26432     +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
26433     +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
26434     +    %end;
26436     +    /* if useIMport=1 also include import definitions here as well */
26437     +    %if &useImport eq 1 %then %do;
26438     +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
26439     +    %end;
26440     +    %if &useFreeze eq 1 %then %do;
26441     +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
26442     +    %end;
26443     +    data &EM_USER_SPLITVALS;
26444     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
26445     +        merge &EM_USER_SPLITVALS tempsplitvals
26446     +        %if &useImport eq 1 %then %do;
26447     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
26448     +        %end;
26449     +        %if &useFreeze eq 1 %then %do;
26450     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
26451     +        %end;
26453     +        ;
26454     +        by _variable_ _split_value_
26455     +        ;
26456     +      %end;
26457     +      %else %do;
26458     +        set tempsplitvals
26459     +        %if &useImport eq 1 %then %do;
26460     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
26461     +        %end;
26462     +        %if &useFreeze eq 1 %then %do;
26463     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
26464     +        %end;
26465     +        ;
26466     +      %end;
26467     +      if display_var eq "" then delete;
26468     +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
26469     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
26470     +    run;
26472     +    proc sort data=&EM_USER_SPLITVALS;
26473     +      by DISPLAY_VAR _Group_;
26474     +    run;
26476     +   /* delete temporary datasets */
26477     +   proc datasets library= work nolist;
26478     +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
26479     +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
26480     +       tempmissvalues
26481     +     %end;
26482     +     ;
26483     +   run;
26484     +   quit;
26485     +%mend EM_CLASSVARS_GROUP;
26488     +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
26490     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
26492     +  data temptrain ;
26493     +    set &data;
26494     +  run;
26496     +  /* normalize all values prior to calculating counts */
26497     +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
26498     +  %include _temp;
26499     +  filename _temp;
26500     +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
26501     +  %include _temp;
26502     +  filename _temp;
26504     +  proc sort data=&EM_USER_VARMAPPINGS
26505     +  %if &varname ne %then %do;
26506     +    (where=(_variable_="&varname"))
26507     +  %end;
26508     +  out=tempmap; by _variable_; run;
26510     +  data _cmeta;
26511     +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
26512     +    by name;
26513     +    if ((_a) or (role="TARGET"));
26514     +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
26515     +    %if %length(%EM_BINARY_TARGET) %then %do;
26516     +      if role="TARGET" then role="INPUT";
26517     +    %end;
26518     +    level = procLevel;
26519     +    index = kindex(name, "BIN_");
26520     +    if index gt 0 then do;
26521     +     level="ORDINAL";
26522     +     format = "";
26523     +    end;
26524     +    drop index;
26525     +  run;
26527     +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
26528     +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N, outdata=_tmp_train);
26530     +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
26532     +  data _null_;
26533     +    set sortedmap end=eof;
26534     +    by _proc_var_;
26535     +    if _n_=1 then do;
26536     +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
26537     +      call execute("ods listing close;");
26538     +      call execute("proc freq data=_tmp_train order=formatted addnames;");
26539     +      call execute("tables ("||_proc_var_);
26540     +    end;
26541     +    else do;
26542     +      call execute(_proc_var_);
26543     +    end;
26544     +    if eof then do;
26545     +      call execute(") * &ignbintarget/ missing;");
26546     +      %if %EM_FREQ ne %then %do;
26547     +        call execute("weight %EM_FREQ;");
26548     +      %end;
26549     +      call execute("run;");
26550     +      call execute("ods output close;");
26551     +      call execute("ods listing;");
26552     +    end;
26553     +  run;
26555     +  data _null_;
26556     +    set sortedmap end=eof;
26557     +    by _proc_var_;
26558     +    if _n_=1 then do;
26559     +      call execute("data crosstabs;");
26560     +      call execute("  length _variable_ _split_value_  $200 ;");
26561     +      call execute("  set crosstabfreq(where=(_type_='11'));");
26562     +      call execute("  _variable_= RowVariable;");
26563     +    end;
26565     +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
26566     +    call execute("  _split_value_="||_proc_var_||";");
26567     +    call execute("end;");
26569     +    if eof then do;
26570     +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent display_var;");
26571     +      call execute("run;");
26572     +    end;
26573     +  run;
26575     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
26577     +  data crosstabs;
26578     +    length display_var $32;
26579     +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
26580     +    by _variable_;
26581     +  run;
26583     +  proc sort data=crosstabs; by display_var _split_value_; run;
26584     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
26586     +  data crosstabs;
26587     +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
26588     +    by display_var;
26589     +    index = kindex(_variable_, "BIN_");
26590     +    if index gt 0 then do;
26591     +     level="ORDINAL";
26592     +     format = "";
26593     +    end;
26594     +    _temp = &ignbintarget;
26595     +    /*
26596     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
26597     +      %if &target_format ne %then %do;
26598     +        %if &target_type eq C %then %do;
26599     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
26600     +        %end;
26601     +        %else %do;
26602     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
26603     +        %end;
26604     +      %end;
26605     +      %else %do;
26606     +        %dmnormcp(&ignbintarget, _temp);
26607     +      %end;
26608     +    %end;
26609     +    %else %do;
26610     +      _temp = &ignbintarget;
26611     +    %end;
26612     +*/
26614     +    drop index;
26615     +  run;
26617     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
26619     +  data &outdata;
26620     +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate  8 type $1 valfmt $20 ;
26622     +    retain eventCount noneventCount ;
26623     +    set crosstabs;
26624     +    by  _variable_ _split_value_;
26626     +    if first._split_value_ then do;
26627     +     total=0;
26628     +     eventcount=0;
26629     +     noneventcount=0;
26630     +    end;
26632     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
26633     +      %if &target_format ne %then %do;
26634     +        if upcase(strip(_temp))="&target_event" then
26635     +          eventCount=Frequency;
26636     +      %end;
26637     +      %else %do;
26638     +         if upcase(strip(_temp)) ="&target_event" then
26639     +          eventCount=Frequency;
26640     +      %end;
26641     +    %end;
26642     +    %else %do;
26643     +      if _temp=&target_event then
26644     +        eventCount=Frequency;
26645     +    %end;
26646     +    else
26647     +      noneventCount=Frequency;
26649     +    if last._split_value_ then do;
26650     +      total = eventCount + noneventCount;
26652     +      if total ne 0 then do;
26653     +        eventRate = eventCount / total;
26654     +        nonEventRate = nonEventCount / total;
26655     +      end;
26656     +      else do;
26657     +        eventRate = 0;
26658     +        nonEventRate = 0;
26659     +      end;
26660     +     output;
26661     +    end;
26662     +    valfmt = format;
26664     +    drop _temp Frequency percent;
26665     +   run;
26667     +%mend EM_SUMMARIZE_TABLE;
26670     +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings, interactiveFlag=0);
26672     +   proc freq data=&bindata noprint;
26673     +     table &ignbintarget / missing out=temptargetB;
26674     +     %if %EM_FREQ ne %then %do;
26675     +       weight %EM_FREQ;
26676     +     %end;
26677     +   run;
26679     +   %let tdsid = %sysfunc(open(work.temptargetB));
26680     +   %if &tdsid %then %do;
26681     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
26682     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
26684     +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
26685     +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26686     +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
26687     +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26690     +      %let obs = %sysfunc(fetch(&tdsid));
26691     +      %do %while(&obs = 0);
26692     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
26693     +           %if &target_type eq C %then %do;
26694     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
26695     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26696     +           %end;
26697     +           %else
26698     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
26700     +           %if &target_format ne %then %do;
26701     +              %if &target_type eq C %then %do;
26702     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
26703     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26704     +              %end;
26705     +              %else
26706     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
26707     +           %end;
26708     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
26709     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
26711     +           %if "&tarvalue" eq "&target_event" %then %do;
26712     +             %let totalevent = &count;
26713     +           %end;
26714     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
26715     +              %let totalnonevent= &count;
26716     +           %end;
26717     +         %end;
26718     +         %else %do;
26719     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
26720     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
26722     +           %if &tarvalue eq &target_event %then %do;
26723     +             %let totalevent = &count;
26724     +           %end;
26725     +           %else %if &tarvalue eq &target_nonevent %then %do;
26726     +              %let totalnonevent= &count;
26727     +           %end;
26728     +         %end;
26729     +         %let obs = %sysfunc(fetch(&tdsid));
26730     +      %end;
26731     +   %end;
26732     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
26734     +   proc datasets lib=work nolist;
26735     +      delete temptargetB;
26736     +   run;
26737     +   quit;
26739     +   %if &interactiveFlag eq 0 %then %do;
26740     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
26741     +   %end;
26742     +   %else %do;
26743     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar);
26744     +   %end;
26747     +   data &fineDetailData;
26748     +     length display_var $32 newgroup numsplitval 8;
26749     +     set &fineDetailData;
26751     +     display_var = _variable_;
26753     +     index = kindex(display_var, "BIN_");
26754     +     if index gt 0 then do;
26755     +       display_var = ksubstr(display_var, 5);
26756     +     end;
26758     +     index2 = kindex(display_var, "SV_");
26759     +     if index2 gt 0 then do;
26760     +       display_var = ksubstr(display_var, 4);
26761     +     end;
26763     +     /* re-code missing values to "Missing" */
26764     +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
26765     +     _index_ = _N_;
26766     +     newgroup = .;
26767     +     drop index index2 ;
26768     +   run;
26770     +   /* add group information to fineDetailData; */
26771     +   /* add label information for binned variables to fineDetailData*/
26773     +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
26775     +   data tmpsplitvals;
26776     +     set &splitvals;
26777     +     _norm_level_ = upcase(_norm_level_);
26778     +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
26779     +    * drop _split_value_;
26780     +   run;
26782     +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
26783     +   proc datasets library=work nolist;
26784     +     delete tmpsplitvals;
26785     +   run;
26786     +   quit;
26788     +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
26790     +   data &fineDetailData;
26791     +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
26792     +      by _variable_ _split_value_;
26793     +      if _a then do;
26794     +        binFlag = 1;
26795     +        VALUE=EM_BIN_LABEL;
26796     +      end;
26797     +      else do;
26798     +        binFlag = 0;
26799     +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
26800     +        VALUE=strip(_split_value_);
26802     +      end;
26804     +      if ((eventCount=.) or (nonEventCount=.)) then do;
26805     +        eventCount=0;
26806     +        nonEventCount=0;
26807     +        total = 0;
26808     +        eventRate= 0;
26809     +        nonEventRate = 0;
26810     +      end;
26812     +      eventCount = round(eventCount, .001);
26813     +      nonEventCount = round(nonEventCount, .001);
26814     +      total= round(total, .001);
26815     +      eventRate = round(eventRate, .001);
26816     +      nonEventRate = round(nonEventRate, .001);
26818     +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
26819     +         numsplitval = _split_value_;
26820     +     else if ((type='N') AND (valfmt ne "")) then
26821     +        numsplitval = _order_;
26822     +     else numsplitval=.;
26824     +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
26825     +      if _a and ^_b then delete;
26826     +      if _c and ^_b then delete;
26827     +      drop NAME EM_BIN_LABEL valfmt;
26828     +   run;
26830     +   /* for class variables that have values falling into the "other" category, set _LEVEL_ and _GROUP_ based on Missing level */
26831     +   data &fineDetailData;
26832     +     set &fineDetailData;
26834     +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
26835     +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
26836     +     %if &dsid %then %do;
26837     +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
26838     +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
26839     +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
26841     +       %let obs = %sysfunc(fetch(&dsid));
26842     +       %do %while(&obs=0);
26843     +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
26844     +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
26845     +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
26847     +         if DISPLAY_VAR = "&dispvar" then do;
26848     +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
26849     +           if _GROUP_ = . then _GROUP_ = &group;
26850     +         end;
26852     +         %let obs = %sysfunc(fetch(&dsid));
26853     +       %end;
26854     +     %end;
26855     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
26856     +     if _GROUP_ = . then delete;
26857     +    * if binFlag=1 and UB=LB then delete;
26858     +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
26859     +   run;
26861     +   proc sort data=&fineDetailData;
26862     +     by DISPLAY_VAR _index_;
26863     +   run;
26865     +   proc datasets lib=work nolist;
26866     +     delete sortedsplit sortedbin
26867     +     ;
26868     +   run;
26869     +   quit;
26870     +%mend EM_FINE_DETAIL;
26872     +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
26874     +   proc freq data=&bindata noprint;
26875     +     table &ignbintarget / missing out=temptargetC;
26876     +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
26877     +     %end;
26878     +   run;
26880     +   %let tdsid = %sysfunc(open(work.temptargetC));
26881     +   %if &tdsid %then %do;
26882     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
26883     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
26885     +      %let obs = %sysfunc(fetch(&tdsid));
26886     +      %do %while(&obs = 0);
26887     +        /* %if &target_type eq C or &target_format ne %then %do; */
26888     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
26889     +           %if &target_type eq C %then %do;
26890     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
26891     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26892     +           %end;
26893     +           %else
26894     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
26896     +           %if &target_format ne %then %do;
26897     +              %if &target_type eq C %then %do;
26898     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
26899     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
26900     +              %end;
26901     +              %else
26902     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
26903     +           %end;
26904     +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
26905     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
26907     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
26908     +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
26909     +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
26911     +           %if "&tarvalue" eq "&target_event" %then %do;
26912     +             %let totalevent = &count;
26913     +           %end;
26914     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
26915     +              %let totalnonevent= &count;
26916     +           %end;
26917     +         %end;
26918     +         %else %do;
26919     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
26920     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
26922     +           %if &tarvalue eq &target_event %then %do;
26923     +             %let totalevent = &count;
26924     +           %end;
26925     +           %else %if &tarvalue eq &target_nonevent %then %do;
26926     +              %let totalnonevent= &count;
26927     +           %end;
26928     +         %end;
26929     +         %let obs = %sysfunc(fetch(&tdsid));
26930     +      %end;
26931     +   %end;
26932     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
26934     +   proc datasets lib=work nolist;
26935     +      delete temptargetC;
26936     +   run;
26937     +   quit;
26939     +   proc means data=&FINEDETAILDATA noprint;
26940     +      var eventCount nonEventCount;
26941     +      class _variable_  _group_;
26942     +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
26943     +   run;
26945     +   proc sort data=summ(drop=_type_ _freq_);
26946     +     by _variable_ _group_;
26947     +   run;
26949     +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
26950     +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
26951     +        set summ;
26952     +        *format groupresprate 6.2;
26953     +        *format groupnonresprate 6.2;
26954     +        by _variable_ ;
26955     +        if _group_=. then do;
26956     +        end;
26957     +        else do;
26958     +           respper = eventCount / &totalEvent;
26959     +           nrespper = nonEventCount / &totalNonEvent;
26961     +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
26962     +                groupresprate=0;
26963     +                groupNonresprate = 0;
26964     +                eventRate = 0;
26965     +                nonEventRate = 0;
26966     +           end;
26967     +           else do;
26968     +               groupresprate = eventCount / (eventCount + nonEventCount) ;
26969     +               groupNonRespRate = 1 - groupRespRate;
26970     +               eventRate = eventCount / &totalEvent ;
26971     +               nonEventRate = nonEventCount / &totalNonEvent ;
26972     +            end;
26974     +           output gini tempcoarse;
26976     +        end;
26977     +   run;
26978     +   proc sort data=gini;
26979     +      by _variable_ descending groupresprate;
26980     +   run;
26982     +   data gini(keep= _variable_ _gini_);
26983     +     retain between within cumresp cumnresp;
26984     +     set gini(keep=_variable_  eventCount nonEventCount);
26985     +     by _variable_;
26986     +     if first._variable_ then do;
26987     +       between  = 0;
26988     +       within   = 0;
26989     +       cumresp  = 0;
26990     +       cumnresp = 0;
26991     +     end;
26992     +     between + 2 * cumnresp * eventCount;
26993     +     within + nonEventCount * eventCount;
26994     +     cumresp + eventCount;
26995     +     cumnresp + nonEventCount;
26996     +     if last._variable_ then do;
26997     +       if ^(cumnresp=0 or cumresp=0) then do;
26998     +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
26999     +         output;
27000     +       end;
27001     +     end;
27002     +   run;
27004     +   data tempdisplayvar;
27005     +      set &EM_USER_VARMAPPINGS;
27006     +      rename _variable_ = display_var
27007     +      _proc_var_ = _variable_;
27008     +   keep _variable_ _proc_var_ label;
27009     +   run;
27010     +   proc sort data=tempdisplayvar; by _variable_; run;
27012     +   data  &COARSE;
27013     +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
27014     +     merge tempdisplayvar tempcoarse gini ;
27015     +     by _variable_;
27016     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
27017     +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel , NOQUOTE))"
27018     +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel , NOQUOTE))"
27019     +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel , NOQUOTE))"
27020     +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel , NOQUOTE))"
27021     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  , NOQUOTE))"
27022     +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  , NOQUOTE))"
27023     +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel  , NOQUOTE))"
27024     +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel  , NOQUOTE))"
27025     +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupnonresprate_vlabel  , NOQUOTE))"
27026     +           ;
27028     +    eventCount = round(eventCount, .001);
27029     +    nonEventCount = round(nonEventCount, .001);
27030     +    groupRespRate = round(groupRespRate, .001);
27032     +     drop _variable_ index index2 respper nrespper;
27033     +   run;
27035     +   proc datasets library=work nolist;
27036     +     delete  tempcoarse gini             ;
27038     +   run;
27039     +   quit;
27041     +%mend EM_CREATE_GROUPING;
27045     +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
27047     +         data _null_;
27048     +            FILE &filename;
27049     +            put " length _LABEL_ $200;";
27050     +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
27051     +         run;
27053     +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var _split_Value_; run;
27054     +         proc sort data=&BINMAPPINGS; by display_var bin; run;
27056     +         data temp;
27057     +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
27058     +           by Display_Var _Split_value_;
27059     +           if upcase(_Split_value_) ne 'MISSING';
27060     +           if _a then output;
27061     +           if display_var eq '' then delete;
27062     +         run;
27064     +         data temp_missing;
27065     +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
27066     +           by Display_Var _Split_value_;
27067     +           if upcase(_Split_value_) eq 'MISSING';
27068     +           if _a then output;
27069     +           keep _variable_ display_var missgrp;
27070     +         run;
27072     +         proc sort data=temp out=class;
27073     +            by _variable_ _group_ LB;
27074     +         run;
27076     +         data _null_;
27078     +            file &filename MOD;
27079     +            length string $200 flag 8;
27080     +            retain string flag;
27081     +            set class end=eof;
27082     +            by _variable_  _group_;
27084     +            index = kindex(_variable_, "BIN_");
27085     +            if index gt 0 then do;
27086     +              if first._group_ then do;
27087     +                flag = 0;
27088     +                if ^first._variable_ then
27089     +                    put 'else';
27090     +                 else
27091     +                    put ' ';
27093     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
27094     +                          !!strip(put(_GROUP_,best12.))!!' then do;';
27095     +                 put string;
27097     +                 if LB ne . then do;
27098     +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
27099     +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
27100     +                 end;
27101     +                 else do;
27102     +                    flag = 1;
27103     +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
27104     +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
27105     +                 end;
27107     +              end;
27108     +              if last._Group_ then do;
27109     +                 if UB ne . then do;
27110     +                    string = strip(string)!!'< '!!strip(UB)!!"';";
27111     +                 end;
27112     +                 else do;
27113     +                    if flag=1 then do;
27114     +                      string = strip(string)!!"';";
27115     +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
27116     +                    end;
27117     +                    else do;
27118     +                      string = strip(string)!!"';";
27119     +                    end;
27120     +                 end;
27121     +                 put string;
27123     +                 string= " UB="!!strip(UB)!!";";
27124     +                 put string;
27125     +                 put "end;";
27128     +              end;
27129     +            end;
27130     +            else do;
27131     +              _split_value_ = tranwrd(_split_value_,"'","''");
27132     +              if first._group_ then do;
27133     +                 flag = 0;
27134     +                 if ^first._variable_ then
27135     +                    put 'else';
27136     +                 else
27137     +                    put ' ';
27138     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
27139     +                          !!strip(put(_GROUP_,best12.))!!' then';
27140     +                 put string;
27141     +                 string = "_LABEL_='"!!strip(_split_value_);
27142     +              end;
27143     +              else do;
27144     +                 if flag ne 1 then do;
27145     +                   tempstring = strip(string)!!', '!!strip(_split_value_);
27146     +                   length = length(tempstring);
27148     +                   if length < 195 then do;
27149     +                      string = tempstring;
27150     +                   end;
27151     +                   else do;
27152     +                      string = strip(string)||",...";
27153     +                      flag=1;
27154     +                   end;
27155     +                 end;
27156     +              end;
27158     +              if last._group_ then do;
27159     +                 string = strip(string)!!"';";
27160     +                 put string;
27161     +              end;
27162     +            end;
27163     +         run;
27165     +         data &COARSE;
27166     +           set &COARSE;
27167     +          /* %inc Y; */
27168     +           %inc &filename;
27169     +         run;
27170     +         *filename Y;
27172     +         /* add missing to appropriate label - based on temp_missing data */
27173     +         data &COARSE;
27174     +           set &COARSE;
27176     +           %let dsid = %sysfunc(open(work.temp_missing));
27177     +           %if &dsid %then %do;
27178     +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
27179     +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
27181     +              %let obs = %sysfunc(fetch(&dsid));
27182     +              %do %while(&obs=0);
27183     +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
27184     +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
27186     +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
27187     +                   if _LABEL_ eq '' then do;
27188     +                     _LABEL_ = "Missing";
27189     +                   end;
27190     +                   else do;
27191     +                     _LABEL_ = strip(_LABEL_)!!", Missing";
27192     +                   end;
27193     +                 end;
27194     +                 %let obs = %sysfunc(fetch(&dsid));
27195     +              %end;
27196     +           %end;
27197     +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
27198     +           drop ub;
27199     +         run;
27201     +         proc datasets library=work nolist;
27202     +           delete class temp temp_missing;
27203     +         run;
27204     +         quit;
27206     +%mend EM_GENERATE_LABELVALUES;
27208     +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
27211     +%mend calcValidationCoarse;
27214     +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
27215     +/* macro for transforming interval target to binary */
27217     +   %if &method = CUTMEAN %then %do;
27218     +      proc sql noprint;
27219     +         %if %EM_FREQ ne %then %do;
27220     +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
27221     +         %end;
27222     +         %else %do;
27223     +            select mean(&inttgtvar)
27224     +         %end;
27225     +         into :ignbincut from &em_import_data;
27226     +      quit;
27227     +   %end;
27229     +   /* create binary target */
27230     +   data &EM_USER_NEWTRAIN;
27231     +      set &EM_IMPORT_DATA;
27232     +      %if &method = CUTUSER %then %do;
27233     +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
27234     +      %end;
27235     +      if &inttgtvar = . then &IGNBinTarget = .;
27236     +      else do;
27237     +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
27238     +         else &IGNBinTarget=0;
27239     +      end;
27240     +   run;
27242     +   /* Check that new target is actually binary */
27243     +   proc sql noprint;
27244     +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where &IGNBinTarget ne .;
27245     +   quit;
27246     +   %global &newlevels;
27247     +   %let &newlevels=&sqlobs;
27249     +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select mean(SalePrice) into :ignbincut from EMWS1.Trans_TRAIN;
NOTE: There were 145 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 129 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.17 seconds
      cpu time            0.17 seconds
      
NOTE: There were 129 observations read from the data set EMWS1.VARSEL_TRAIN.
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.19 seconds
      cpu time            0.20 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   data EMWS1.BINNING_NEWTRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   set EMWS1.Trans_TRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice = . then BIN_SalePrice = .;
MPRINT(EM_IBN_INTTARGETTRANS):   else do;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice > 76154.12 then BIN_SalePrice=1;
MPRINT(EM_IBN_INTTARGETTRANS):   else BIN_SalePrice=0;
MPRINT(EM_IBN_INTTARGETTRANS):   end;
MPRINT(EM_IBN_INTTARGETTRANS):   run;

NOTE: There were 145 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 129 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.19 seconds
      cpu time            0.18 seconds
      
NOTE: There were 129 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 129 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set EMWS1.BINNING_NEWTRAIN has 129 observations and 22 variables.
NOTE: DATA statement used (Total process time):
      real time           0.23 seconds
      cpu time            0.23 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select distinct BIN_SalePrice into :bintv1 - from EMWS1.BINNING_NEWTRAIN where BIN_SalePrice ne .;
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 11 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 11 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 11 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 11 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 11 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 11 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS1.BINNING_VARMAPPINGS(keep=_variable_ _grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Input Variable" _grp_variable_ = "Group Variable";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 11 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 6 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 6 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=4,
      Created=Tue, Nov 17, 2015 02:13:13 PM,
      Last Modified=Tue, Nov 17, 2015 02:13:13 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary Files\_TD4804_COB-IT-M13_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 7 records were written to the file MACFILE.
      The minimum record length was 19.
      The maximum record length was 52.
NOTE: There were 6 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
27254     +%macro intervalvars;
27255     +Age Baths FirePlace GarageSize SecondFloor TotalArea
27256     +%mend intervalvars;
27257     +%global num_intvars;
27258     +%let num_intvars = 6 ;
27259     +%global num_intvars;
27260     +%let num_intvars = 6 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS1.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   Age Baths FirePlace GarageSize SecondFloor TotalArea
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 129   Memory used = 511K.
NOTE: There were 129 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 23 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 23 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 3 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 23 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 23 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 23 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 6 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 6 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Level for Interactive";
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 11 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
27262     +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode, codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
27264     +  /* initialize binmappings table */
27265     +  data &BINMAPPINGS;
27266     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
27267     +  run;
27271     +  %if &IncludeTarget=N %then %do;
27272     +   /* process only INTERVAL INPUTS */
27273     +  data tempvars;
27274     +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
27275     +  run;
27276     +  %end;
27278     +  %if &IncludeTarget=Y %then %do;
27279     +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
27280     +  data tempvars;
27281     +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND LEVEL="INTERVAL")));
27282     +  run;
27283     +  %end;
27285     +  /* retrieve the name of interval inputs to bin */
27286     +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
27287     +  %include tempopen;
27288     +  filename tempopen;
27290     +  %let intvars = ;
27291     +  %global num_intvars;
27292     +  %let num_intvars = 0;
27293     +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
27295     +  /* retrieve the name of frequency variable if it exists */
27296     +  %let em_bin_freq = ;
27297     +  %let choice = ROLE="FREQ";
27298     +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
27299     +  %if &fdsid %then %do;
27300     +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
27301     +    %let fobs = %sysfunc(fetch(&fdsid));
27302     +    %do %while(&fobs=0);
27303     +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
27304     +       %let fobs = %sysfunc(fetch(&fdsid));
27305     +    %end;
27306     +  %end;
27307     +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
27309     +  /* process all inputs */
27310     +  %if &num_intvars > 0 %then %do;
27312     +    /* Computing quantile binning of interval inputs */
27313     +    %let numbin = %eval(&NUMBINS - 1);
27314     +    %let optstr=;
27315     +    %do i=1 %to &numbin;
27316     +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
27317     +    %end;
27319     +    data tempInt / view = tempInt;
27320     +      set &input(keep= %intvars
27321     +      %if &em_bin_freq ne %then %do;
27322     +        &em_bin_freq
27323     +      %end;
27324     +      );
27325     +    run;
27327     +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
27328     +       var %intvars;
27329     +       %if &em_bin_freq ne %then %do;
27330     +          freq &em_bin_freq / notrunc;
27331     +       %end;
27332     +    run;
27334     +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
27335     +    run;
27337     +    /* generate unique BIN_xxx names for all inputs processed */
27338     +    proc dmdb data=tempvars outtable=tempmapping nameserver;
27339     +     names NAME;
27340     +     prefix BIN_ ;
27341     +    run;
27343     +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
27344     +    proc sort data=work.pctdata; by _NAME_; run;
27345     +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
27346     +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar variable) ; by codeVar; run;
27347     +    %end;
27349     +    data tempbins;
27350     +      length display_var $32;
27351     +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
27352     +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
27353     +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
27354     +      %end;
27355     +      ;
27356     +      by _NAME_;
27357     +      if _a;
27358     +      if missing(display_var) then display_var = _NAME_;
27359     +    run;
27361     +    /* generate BINMAPPINGS dataset and binningCode file*/
27362     +    data _null_;
27363     +      FILE &binningCode;
27364     +      set tempbins end=eof;
27365     +      length string $200;
27366     +      by _NAME_;
27368     +      if _n_=1 then do;
27369     +        put "&EM_CODEBAR;";
27370     +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
27371     +        put "* &note;";
27372     +        put "&EM_CODEBAR;";
27374     +        call execute(" data &BINMAPPINGS; ");
27375     +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
27376     +      end;
27378     +      %do i=1 %to %eval(&numbins-1);
27379     +       %if &i eq 1 %then %do;
27380     +         %let colname = COL&i;
27381     +         %let binvalnum = 1;
27382     +         LB = .;
27383     +         UB = round(&colname, &precision);
27384     +         bin=&binvalnum;
27386     +         call execute("name='"||strip(_NAME_)||"'; ");
27387     +         call execute("bin_name='"||strip(binVar)||"'; ");
27388     +         call execute("bin='"||strip(bin)||"';");
27389     +         call execute("LB=.;");
27390     +         call execute("UB="||UB||";");
27391     +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
27392     +         call execute("output;");
27394     +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
27396     +         put string;
27397     +         string = "else do;";
27398     +         put string;
27400     +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
27401     +         put string;
27404     +       %end;
27405     +       %else %do;
27406     +         %let colname = COL&i;
27407     +         %let lbnum = %sysevalf(&i-1);
27408     +         %let lbcol = COL&lbnum;
27409     +         UB = round(&colname, &precision);
27410     +         LB = round(&lbcol, &precision);
27411     +         if UB ne LB then do;
27412     +           bin=bin+1;
27414     +           call execute("name='"||strip(_NAME_)||"'; ");
27415     +           call execute("bin_name='"||strip(binVar)||"'; ");
27416     +           call execute("bin='"||strip(bin)||"';");
27417     +           call execute("LB="||LB||";");
27418     +           call execute("UB="||UB||";");
27419     +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
27420     +           call execute("output;");
27422     +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
27423     +           put string;
27425     +         end;
27426     +       %end;
27427     +      %end;
27428     +      %let binvalnum = %sysevalf(&binvalnum + 1);
27429     +      bin=bin+1;
27430     +      LB = round(&colname, &precision);
27431     +      UB = .;
27433     +      call execute("name='"||strip(_NAME_)||"'; ");
27434     +      call execute("bin_name = '"||strip(binVar)||"'; ");
27435     +      call execute("bin='"||strip(bin)||"';");
27436     +      call execute("UB=.;");
27437     +      call execute("LB="||LB||";");
27438     +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
27439     +      call execute("output;");
27441     +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
27442     +      put string;
27443     +      string="end;";
27444     +      put string;
27446     +      if eof then do;
27447     +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
27448     +        call execute("  if LB=UB then delete;");
27449     +        call execute("run;");
27450     +      end;
27452     +    run;
27454     +    /* drop original inputs */
27455     +    %if &dropOriginal=Y %then %do;
27456     +      data _null_;
27457     +        set work.tempvars end=eof;
27458     +        FILE &binningCode MOD;
27459     +        length string $200;
27461     +        if _n_=1 then do;
27462     +          put "drop";
27463     +        end;
27464     +        string = " "||strip(name);
27465     +        put string;
27467     +        if eof then do;
27468     +          put ";";
27469     +        end;
27470     +      run;
27471     +    %end;
27473     +    proc datasets library=work nolist;
27474     +      delete pctdata tempmapping tempbins tempInt;
27475     +    run;
27476     +    quit;
27477     +  %end;
27479     +  proc datasets library=work nolist;
27480     +    delete tempvars;
27481     +  run;
27482     +  quit;
27484     +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 6 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 6 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
27488     +
27489     +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=);
27490     +
27491     +   filename macFile catalog 'work.emutil.macro.source';
27492     +   %let _METAOBS = 0;
27493     +
27494     +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
27495     +                   or (&metadata eq ) %then %do;
27496     +       %put * No metadata data set defined;
27497     +       %goto doend;
27498     +   %end;
27499     +
27500     +   data _null_;
27501     +      length _STRING_ $80;
27502     +      retain _STRING_;
27503     +      set &metadata end=eof;
27504     +      file macFile;
27505     +      %if %nrbquote(&where) ne %then %do;
27506     +          %let whereClause = where (%nrbquote(&where));
27507     +          %unquote(&whereClause);
27508     +      %end;
27509     +      if _N_=1 then do;
27510     +         string = "%"!!"macro &name;";
27511     +         put string;
27512     +      end;
27513     +      if (length(_STRING_) + length(trim(&key))+ 1 < 80) then do;
27514     +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
27515     +         if eof then do;
27516     +            put _STRING_;
27517     +            string = "%"!!"mend &name;";
27518     +            put string;
27519     +            %if (&nummacro ne ) %then %do;
27520     +                string = strip(put(_N_, best.));
27521     +                put "%" "global &nummacro;";
27522     +                put "%" "let &nummacro = " string ";";
27523     +                call symput('_METAOBS', string);
27524     +            %end;
27525     +         end;
27526     +      end;
27527     +      else do;
27528     +         put _STRING_;
27529     +         _string_ = TRIM(&key);
27530     +         if eof then do;
27531     +            put _STRING_;
27532     +            string = "%"!!"mend &name;";
27533     +            put string;
27534     +        end;
27535     +      end;
27536     +      if eof then do;
27537     +         string = strip(put(_N_, best.));
27538     +         call symput('_METAOBS', string);
27539     +         %if (&nummacro ne ) %then %do;
27540     +             put "%" "global &nummacro;";
27541     +             put "%" "let &nummacro = " string ";";
27542     +         %end;
27543     +      end;
27544     +   run;
27545     +
27546     +   %doend:
27547     +   %if ^&_METAOBS %then %do;
27548     +       data _null_;
27549     +          file macFile;
27550     +          put "%" "macro &name;";
27551     +          put "%" "mend &name;";
27552     +          %if (&nummacro ne ) %then %do;
27553     +              put "%" "global &nummacro;";
27554     +              put "%" "let &nummacro = 0;";
27555     +          %end;
27556     +      run;
27557     +   %end;
27558     +   %inc macFile;
27559     +   filename macFile;
27560     +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Tue, Nov 17, 2015 02:13:13 PM,
      Last Modified=Tue, Nov 17, 2015 02:13:13 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary Files\_TD4804_COB-IT-M13_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 7 records were written to the file MACFILE.
      The minimum record length was 14.
      The maximum record length was 52.
NOTE: There were 6 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
27561     +%macro intvars;
27562     +Age Baths FirePlace GarageSize SecondFloor TotalArea
27563     +%mend intvars;
27564     +%global num_intvars;
27565     +%let num_intvars = 6 ;
27566     +%global num_intvars;
27567     +%let num_intvars = 6 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = Age Baths FirePlace GarageSize SecondFloor TotalArea );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   Age Baths FirePlace GarageSize SecondFloor TotalArea
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.22 seconds
      cpu time            0.23 seconds
      
NOTE: There were 129 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: There were 129 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 7 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.24 seconds
      cpu time            0.25 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 6 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 6 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 6 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 6 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: There were 6 observations read from the data set WORK.PCTDATA.
NOTE: There were 6 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 6 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generating Bins for interval variables;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS1.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139   292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44    357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=17Nov2015:14:13:14,
      Create Time=17Nov2015:14:13:14

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 44;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age < 44';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 44;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 47;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='44 <= Age < 47';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 47;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 51;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='47 <= Age < 51';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 51;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age >= 51';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1 <= Baths < 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths >= 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea < 1154';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1417;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1154 <= TotalArea < 1417';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1417;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1584;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1417 <= TotalArea < 1584';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1584;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea >= 1584';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 38 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 6 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS1.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='Age';
4         + bin_name='BIN_Age';
5         + bin='1';
6         + LB=.;
7         + UB=          44;
8         + EM_BIN_LABEL='Age < 44';
9         + output;
10        + name='Age';
11        + bin_name='BIN_Age';
12        + bin='2';
13        + LB=          44;
14        + UB=          47;
15        + EM_BIN_LABEL='44 <= Age < 47';
16        + output;
17        + name='Age';
18        + bin_name='BIN_Age';
19        + bin='3';
20        + LB=          47;
21        + UB=          51;
22        + EM_BIN_LABEL='47 <= Age < 51';
23        + output;
24        + name='Age';
25        + bin_name = 'BIN_Age';
26        + bin='4';
27        + UB=.;
28        + LB=          51;
29        + EM_BIN_LABEL='Age >= 51';
30        + output;
31        + name='Baths';
32        + bin_name='BIN_Baths';
33        + bin='1';
34        + LB=.;
35        + UB=           1;
36        + EM_BIN_LABEL='Baths < 1';
37        + output;
38        + name='Baths';
39        + bin_name='BIN_Baths';
40        + bin='2';
41        + LB=           1;
42        + UB=           2;
43        + EM_BIN_LABEL='1 <= Baths < 2';
44        + output;
45        + name='Baths';
46        + bin_name = 'BIN_Baths';
47        + bin='3';
48        + UB=.;
49        + LB=           2;
50        + EM_BIN_LABEL='Baths >= 2';
51        + output;
52        + name='FirePlace';
53        + bin_name='BIN_FirePlace';
54        + bin='1';
55        + LB=.;
56        + UB=           1;
57        + EM_BIN_LABEL='FirePlace < 1';
58        + output;
59        + name='FirePlace';
60        + bin_name = 'BIN_FirePlace';
61        + bin='2';
62        + UB=.;
63        + LB=           1;
64        + EM_BIN_LABEL='FirePlace >= 1';
65        + output;
66        + name='GarageSize';
67        + bin_name='BIN_GarageSize';
68        + bin='1';
69        + LB=.;
70        + UB=           1;
71        + EM_BIN_LABEL='GarageSize < 1';
72        + output;
73        + name='GarageSize';
74        + bin_name = 'BIN_GarageSize';
75        + bin='2';
76        + UB=.;
77        + LB=           1;
78        + EM_BIN_LABEL='GarageSize >= 1';
79        + output;
80        + name='SecondFloor';
81        + bin_name='BIN_SecondFloor';
82        + bin='1';
83        + LB=.;
84        + UB=           0;
85        + EM_BIN_LABEL='SecondFloor < 0';
86        + output;
87        + name='SecondFloor';
88        + bin_name = 'BIN_SecondFloor';
89        + bin='2';
90        + UB=.;
91        + LB=           0;
92        + EM_BIN_LABEL='SecondFloor >= 0';
93        + output;
94        + name='TotalArea';
95        + bin_name='BIN_TotalArea';
96        + bin='1';
97        + LB=.;
98        + UB=        1154;
99        + EM_BIN_LABEL='TotalArea < 1154';
100       + output;
101       + name='TotalArea';
102       + bin_name='BIN_TotalArea';
103       + bin='2';
104       + LB=        1154;
105       + UB=        1417;
106       + EM_BIN_LABEL='1154 <= TotalArea < 1417';
107       + output;
108       + name='TotalArea';
109       + bin_name='BIN_TotalArea';
110       + bin='3';
111       + LB=        1417;
112       + UB=        1584;
113       + EM_BIN_LABEL='1417 <= TotalArea < 1584';
114       + output;
115       + name='TotalArea';
116       + bin_name = 'BIN_TotalArea';
117       + bin='4';
118       + UB=.;
119       + LB=        1584;
120       + EM_BIN_LABEL='TotalArea >= 1584';
121       + output;
122       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
123       +   if LB=UB then delete;
124       + run;

NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 17 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=1204,
      Last Modified=17Nov2015:14:13:14,
      Create Time=17Nov2015:14:13:14

NOTE: 8 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 11.
NOTE: There were 6 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 17 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      76:96   
NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 17 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedmapping nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: 11 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 6 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 6 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 6 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas.
27568     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
27569     +* Generating Bins for interval variables;
MPRINT(EM_QUANTILE_BINNING):   * Generating Bins for interval variables;
27570     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
27571     +if Age eq . then BIN_Age= .;
MPRINT(EM_QUANTILE_BINNING):   if Age eq . then BIN_Age= .;
27572     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27573     +if Age < 44 then BIN_Age=1;
MPRINT(EM_QUANTILE_BINNING):   if Age < 44 then BIN_Age=1;
27574     +else if Age < 47 then BIN_Age=2;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 47 then BIN_Age=2;
27575     +else if Age < 51 then BIN_Age=3;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 51 then BIN_Age=3;
27576     +else if Age >= 51 then BIN_Age=4;
MPRINT(EM_QUANTILE_BINNING):   else if Age >= 51 then BIN_Age=4;
27577     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27578     +if Baths eq . then BIN_Baths= .;
MPRINT(EM_QUANTILE_BINNING):   if Baths eq . then BIN_Baths= .;
27579     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27580     +if Baths < 1 then BIN_Baths=1;
MPRINT(EM_QUANTILE_BINNING):   if Baths < 1 then BIN_Baths=1;
27581     +else if Baths < 2 then BIN_Baths=2;
MPRINT(EM_QUANTILE_BINNING):   else if Baths < 2 then BIN_Baths=2;
27582     +else if Baths >= 2 then BIN_Baths=3;
MPRINT(EM_QUANTILE_BINNING):   else if Baths >= 2 then BIN_Baths=3;
27583     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27584     +if FirePlace eq . then BIN_FirePlace= .;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace eq . then BIN_FirePlace= .;
27585     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27586     +if FirePlace < 1 then BIN_FirePlace=1;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace < 1 then BIN_FirePlace=1;
27587     +else if FirePlace >= 1 then BIN_FirePlace=2;
MPRINT(EM_QUANTILE_BINNING):   else if FirePlace >= 1 then BIN_FirePlace=2;
27588     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27589     +if GarageSize eq . then BIN_GarageSize= .;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize eq . then BIN_GarageSize= .;
27590     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27591     +if GarageSize < 1 then BIN_GarageSize=1;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize < 1 then BIN_GarageSize=1;
27592     +else if GarageSize >= 1 then BIN_GarageSize=2;
MPRINT(EM_QUANTILE_BINNING):   else if GarageSize >= 1 then BIN_GarageSize=2;
27593     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27594     +if SecondFloor eq . then BIN_SecondFloor= .;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor eq . then BIN_SecondFloor= .;
27595     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27596     +if SecondFloor < 0 then BIN_SecondFloor=1;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor < 0 then BIN_SecondFloor=1;
27597     +else if SecondFloor >= 0 then BIN_SecondFloor=2;
MPRINT(EM_QUANTILE_BINNING):   else if SecondFloor >= 0 then BIN_SecondFloor=2;
27598     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27599     +if TotalArea eq . then BIN_TotalArea= .;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea eq . then BIN_TotalArea= .;
27600     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
27601     +if TotalArea < 1154 then BIN_TotalArea=1;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea < 1154 then BIN_TotalArea=1;
27602     +else if TotalArea < 1417 then BIN_TotalArea=2;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1417 then BIN_TotalArea=2;
27603     +else if TotalArea < 1584 then BIN_TotalArea=3;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1584 then BIN_TotalArea=3;
27604     +else if TotalArea >= 1584 then BIN_TotalArea=4;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea >= 1584 then BIN_TotalArea=4;
27605     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
27606     +drop
27607     +Age
27608     +Baths
27609     +FirePlace
27610     +GarageSize
27611     +SecondFloor
27612     +TotalArea
27613     +;
MPRINT(EM_QUANTILE_BINNING):   drop Age Baths FirePlace GarageSize SecondFloor TotalArea ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 129 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set EMWS1.BINNING_BINDATA has 129 observations and 22 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      199:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: There were 6 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 23 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 23 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 23 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 23 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 23 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Tue, Nov 17, 2015 02:13:13 PM,
      Last Modified=Tue, Nov 17, 2015 02:13:13 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary Files\_TD4804_COB-IT-M13_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 0 records were written to the file MACFILE.
NOTE: There were 0 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   put "%" "macro classvars;";
MPRINT(EM_VARMACRO):   put "%" "mend classvars;";
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = 0;";
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Tue, Nov 17, 2015 02:13:13 PM,
      Last Modified=Tue, Nov 17, 2015 02:13:15 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary Files\_TD4804_COB-IT-M13_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 4 records were written to the file MACFILE.
      The minimum record length was 16.
      The maximum record length was 23.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
27614     +%macro classvars;
27615     +%mend classvars;
27616     +%global num_classvars;
27617     +%let num_classvars = 0;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 23 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 23 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 23 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 23 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 5 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS1.Trans_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class CentralAir ConstructionType G_BasementType G_GarageType WallType ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Records processed = 129   Memory used = 511K.
NOTE: There were 145 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 129 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.23 seconds
      cpu time            0.23 seconds
      
NOTE: There were 129 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 129 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 13 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.26 seconds
      cpu time            0.26 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 13 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 13 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 13 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 13 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 13 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 5 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 13 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 5 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 13 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="CentralAir";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="BINARY";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="ConstructionType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="G_BasementType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="G_GarageType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="WallType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "CentralAir" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "BINARY";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "1" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "ConstructionType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "1" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "2" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "3" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "G_BasementType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "1" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "G_GarageType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "2" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "WallType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "2" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "3" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 13 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 5 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 18 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.08 seconds
      cpu time            0.07 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 23 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 23 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 18 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 18 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS1.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 23 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 18 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 41 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 41 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS1.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: 30 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 11 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "AGE" then _proc_var_ = "BIN_Age";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BATHS" then _proc_var_ = "BIN_Baths";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "FIREPLACE" then _proc_var_ = "BIN_FirePlace";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "GARAGESIZE" then _proc_var_ = "BIN_GarageSize";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "SECONDFLOOR" then _proc_var_ = "BIN_SecondFloor";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "TOTALAREA" then _proc_var_ = "BIN_TotalArea";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CENTRALAIR" then _proc_var_ = "CentralAir";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CONSTRUCTIONTYPE" then _proc_var_ = "ConstructionType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "G_BASEMENTTYPE" then _proc_var_ = "G_BasementType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "G_GARAGETYPE" then _proc_var_ = "G_GarageType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "WALLTYPE" then _proc_var_ = "WallType";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 11 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table BIN_SalePrice / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 129 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 14 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS1.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 129 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 129 observations and 22 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
27618     +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
27619     +
27620     +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
27621     +      length INDEXVAR $32; retain _index 0;
27622     +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
27623     +      if strip(LEVEL) eq 'INTERVAL' then delete;
27624     +      else do;
27625     +         _index+1;
27626     +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
27627     +      end;
27628     +   run;
27629     +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
27630     +%macro em_NormalizeClassVars(indata=,
27631     +                          cmeta=,
27632     +                          encodedTarget=N,
27633     +                          target=,
27634     +                          targetEvent=,
27635     +                          targetNonEvent=,
27636     +                          outdata=);
27637     + %let dsid = %sysfunc(open(&cmeta));
27638     + %let vn_name =%sysfunc(varnum(&dsid, NAME));
27639     + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
27640     + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
27641     + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
27642     +
27643     + data &outdata/view=&outdata;
27644     +      length _normedvar32 $32.;
27645     +      set &indata( rename = (
27646     +      %let k = 1;
27647     +      %do %while(^%sysfunc(fetch(&dsid)));
27648     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
27649     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
27650     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
27651     +          &_name = &_indexvar
27652     +          %let k = %eval(&k+1);
27653     +      %end;
27654     +      ));
27655     +      drop  _normedvar32;
27656     +
27657     +      %let rc=%sysfunc(rewind(&dsid));
27658     +      %let k = 1;
27659     +      %do %while(^%sysfunc(fetch(&dsid)));
27660     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
27661     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
27662     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
27663     +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
27664     +          %if &_format ne %then %do;
27665     +              _normedvar32 = put(&_indexvar, &_format);
27666     +          %end;
27667     +          %else %do;
27668     +              %if &_type = N %then %do;
27669     +                  _normedvar32 = put(&_indexvar, Best12.);
27670     +              %end;
27671     +              %else %do;
27672     +                  _normedvar32 = put(&_indexvar, $32.);
27673     +              %end;
27674     +          %end;
27675     +          %DMNORMIP(_normedvar32);
27676     +          &_name = _normedvar32;
27677     +          drop &_indexvar;
27678     +          %let k = %eval(&k+1);
27679     +      %end;
27680     +      %let dsid = %sysfunc(close(&dsid));
27681     +
27682     +      %if &encodedTarget = Y %then %do;
27683     +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
27684     +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
27685     +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
27686     +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0;
27687     +      %end;
27688     + run;
27689     +
27690     +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 11 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      78:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      81:105   
NOTE: There were 14 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 11 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 12 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 11 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 11 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BIN_Age = _INDEXVAR1 BIN_Baths = _INDEXVAR2 CentralAir = _INDEXVAR3 ConstructionType = _INDEXVAR4 BIN_FirePlace = _INDEXVAR5 G_BasementType = _INDEXVAR6 G_GarageType = _INDEXVAR7 
BIN_GarageSize = _INDEXVAR8 BIN_SecondFloor = _INDEXVAR9 BIN_TotalArea = _INDEXVAR10 WallType = _INDEXVAR11 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Age = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Baths = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   CentralAir = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   ConstructionType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_FirePlace = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   G_BasementType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   G_GarageType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_GarageSize = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_SecondFloor = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_TotalArea = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR11, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   WallType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR11;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 11 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * BIN_SalePrice/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * BIN_SalePrice/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 11 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_Age
5         + BIN_Baths
6         + BIN_FirePlace
7         + BIN_GarageSize
8         + BIN_SecondFloor
9         + BIN_TotalArea
10        + CentralAir
11        + ConstructionType
12        + G_BasementType
13        + G_GarageType
14        + WallType
15        + ) * BIN_SalePrice/ missing;
16        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           0.39 seconds
      cpu time            0.17 seconds
      
NOTE: There were 129 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 117 observations and 22 variables.
NOTE: There were 129 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.45 seconds
      cpu time            0.21 seconds
      

17        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
18        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Age' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Age ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Baths' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Baths ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_FirePlace' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_FirePlace ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_GarageSize' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_GarageSize ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_SecondFloor' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_SecondFloor ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_TotalArea' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_TotalArea ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'CentralAir' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=CentralAir ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'ConstructionType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=ConstructionType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'G_BasementType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=G_BasementType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'G_GarageType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=G_GarageType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'WallType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=WallType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 11 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_Age' then do;
6         +   _split_value_=BIN_Age                         ;
7         + end;
8         + if strip(RowVariable) = 'BIN_Baths' then do;
9         +   _split_value_=BIN_Baths                       ;
10        + end;
11        + if strip(RowVariable) = 'BIN_FirePlace' then do;
12        +   _split_value_=BIN_FirePlace                   ;
13        + end;
14        + if strip(RowVariable) = 'BIN_GarageSize' then do;
15        +   _split_value_=BIN_GarageSize                  ;
16        + end;
17        + if strip(RowVariable) = 'BIN_SecondFloor' then do;
18        +   _split_value_=BIN_SecondFloor                 ;
19        + end;
20        + if strip(RowVariable) = 'BIN_TotalArea' then do;
21        +   _split_value_=BIN_TotalArea                   ;
22        + end;
23        + if strip(RowVariable) = 'CentralAir' then do;
24        +   _split_value_=CentralAir                      ;
25        + end;
26        + if strip(RowVariable) = 'ConstructionType' then do;
27        +   _split_value_=ConstructionType                ;
28        + end;
29        + if strip(RowVariable) = 'G_BasementType' then do;
30        +   _split_value_=G_BasementType                  ;
31        + end;
32        + if strip(RowVariable) = 'G_GarageType' then do;
33        +   _split_value_=G_GarageType                    ;
34        + end;
35        + if strip(RowVariable) = 'WallType' then do;
36        +   _split_value_=WallType                        ;
37        + end;
38        + keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
39        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 56 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 56 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 56 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 56 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 56 observations read from the data set WORK.CROSSTABS.
NOTE: There were 11 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 56 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 56 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 56 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 14 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = BIN_SalePrice;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. This might cause unexpected results.
NOTE: There were 56 observations read from the data set WORK.CROSSTABS.
NOTE: There were 14 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 59 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 59 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 59 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 389:122   1 at 398:134   1 at 401:129   
NOTE: There were 59 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 29 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 29 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 29 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 29 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 29 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 41 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 41 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 41 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 17 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS1.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 29 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: There were 41 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 17 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 41 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Age" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Baths" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "CentralAir" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="BINARY";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "ConstructionType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "FirePlace" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "G_BasementType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "G_GarageType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "GarageSize" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "SecondFloor" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "TotalArea" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "WallType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 41 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 41 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table BIN_SalePrice / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 129 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS1.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 52 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 52 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 52 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 67;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 62;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 67 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 62 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 52 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 41 observations and 4 variables.
NOTE: The data set WORK.TEMPCOARSE has 41 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 41 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 41 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 41 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 11 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 11 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 11 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 11 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 11 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS1.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Event Rate" nonEventRate = "Non-Event Rate" _group_ = "Group" role = "Role" _gini_ = "Gini Coefficient" eventcount = "Event Count" noneventcount = "Non-Event Count" groupresprate = 
"Group Event Rate" groupnonresprate = "Group Non-Event Rate" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 11 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 41 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 11 observations read from the data set WORK.GINI.
NOTE: The data set EMWS1.BINNING_COARSE has 41 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.09 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y "C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=17Nov2015:14:13:17,
      Create Time=17Nov2015:14:13:17

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_SPLITVALS out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 41 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 17 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 41 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 30 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 41 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 17 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 11 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 30 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 30 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=108,
      Last Modified=17Nov2015:14:13:17,
      Create Time=17Nov2015:14:13:17

NOTE: 124 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 54.
NOTE: There were 30 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file C:\Users\bteric01\Documents\Tutorials_Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas.
27691     + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
27692     + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Group Values";
27693     +
27694     +if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
27695     +_LABEL_='Age< 44';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Age< 44';
27696     +UB=44;
MPRINT(EM_GENERATE_LABELVALUES):   UB=44;
27697     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27698     +else
27699     +if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
27700     +_LABEL_='44<= Age< 47';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='44<= Age< 47';
27701     +UB=47;
MPRINT(EM_GENERATE_LABELVALUES):   UB=47;
27702     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27703     +else
27704     +if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
27705     +_LABEL_='47<= Age< 51';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='47<= Age< 51';
27706     +UB=51;
MPRINT(EM_GENERATE_LABELVALUES):   UB=51;
27707     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27708     +else
27709     +if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
27710     +_LABEL_='51<= Age';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='51<= Age';
27711     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27712     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27713     +
27714     +if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
27715     +_LABEL_='Baths< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Baths< 1';
27716     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
27717     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27718     +else
27719     +if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
27720     +_LABEL_='1<= Baths< 2';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= Baths< 2';
27721     +UB=2;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2;
27722     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27723     +else
27724     +if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
27725     +_LABEL_='2<= Baths';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2<= Baths';
27726     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27727     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27728     +
27729     +if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
27730     +_LABEL_='FirePlace< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='FirePlace< 1';
27731     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
27732     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27733     +else
27734     +if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
27735     +_LABEL_='1<= FirePlace';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= FirePlace';
27736     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27737     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27738     +
27739     +if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
27740     +_LABEL_='GarageSize< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='GarageSize< 1';
27741     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
27742     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27743     +else
27744     +if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
27745     +_LABEL_='1<= GarageSize';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= GarageSize';
27746     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27747     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27748     +
27749     +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
27750     +_LABEL_='SecondFloor< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='SecondFloor< 0';
27751     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
27752     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27753     +else
27754     +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
27755     +_LABEL_='0<= SecondFloor';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= SecondFloor';
27756     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27757     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27758     +
27759     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
27760     +_LABEL_='TotalArea< 1154';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='TotalArea< 1154';
27761     +UB=1154;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1154;
27762     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27763     +else
27764     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
27765     +_LABEL_='1154<= TotalArea< 1417';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1154<= TotalArea< 1417';
27766     +UB=1417;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1417;
27767     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27768     +else
27769     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
27770     +_LABEL_='1417<= TotalArea< 1584';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1417<= TotalArea< 1584';
27771     +UB=1584;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1584;
27772     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27773     +else
27774     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
27775     +_LABEL_='1584<= TotalArea';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1584<= TotalArea';
27776     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
27777     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
27778     +
27779     +if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then
27780     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then _LABEL_='1';
27781     +else
27782     +if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then
27783     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then _LABEL_='0';
27784     +
27785     +if DISPLAY_VAR='ConstructionType' and _GROUP_ = 2 then
27786     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='ConstructionType' and _GROUP_ = 2 then _LABEL_='1';
27787     +else
27788     +if DISPLAY_VAR='ConstructionType' and _GROUP_ = 3 then
27789     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='ConstructionType' and _GROUP_ = 3 then _LABEL_='2';
27790     +else
27791     +if DISPLAY_VAR='ConstructionType' and _GROUP_ = 4 then
27792     +_LABEL_='3';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='ConstructionType' and _GROUP_ = 4 then _LABEL_='3';
27793     +
27794     +if DISPLAY_VAR='G_BasementType' and _GROUP_ = 2 then
27795     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='G_BasementType' and _GROUP_ = 2 then _LABEL_='1';
27796     +else
27797     +if DISPLAY_VAR='G_BasementType' and _GROUP_ = 3 then
27798     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='G_BasementType' and _GROUP_ = 3 then _LABEL_='0';
27799     +
27800     +if DISPLAY_VAR='G_GarageType' and _GROUP_ = 2 then
27801     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='G_GarageType' and _GROUP_ = 2 then _LABEL_='2';
27802     +else
27803     +if DISPLAY_VAR='G_GarageType' and _GROUP_ = 3 then
27804     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='G_GarageType' and _GROUP_ = 3 then _LABEL_='0';
27805     +else
27806     +if DISPLAY_VAR='G_GarageType' and _GROUP_ = 4 then
27807     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='G_GarageType' and _GROUP_ = 4 then _LABEL_='1';
27808     +
27809     +if DISPLAY_VAR='WallType' and _GROUP_ = 2 then
27810     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='WallType' and _GROUP_ = 2 then _LABEL_='2';
27811     +else
27812     +if DISPLAY_VAR='WallType' and _GROUP_ = 3 then
27813     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='WallType' and _GROUP_ = 3 then _LABEL_='1';
27814     +else
27815     +if DISPLAY_VAR='WallType' and _GROUP_ = 4 then
27816     +_LABEL_='3';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='WallType' and _GROUP_ = 4 then _LABEL_='3';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 41 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Age" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Baths" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "CentralAir" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "ConstructionType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "FirePlace" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "G_BasementType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "G_GarageType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "GarageSize" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "SecondFloor" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "TotalArea" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "WallType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 41 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 41 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE FITSTATISTICS CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "BIN_SalePrice";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
The SAS System

MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.50460565951867;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.12 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27817      *------------------------------------------------------------*;
27818      * End TRAIN: BINNING;
27819      *------------------------------------------------------------*;
27820      

27821      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
27822      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
27823      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27824      ;
MPRINT(EM_DIAGRAM):   ;
27825      ;
MPRINT(EM_DIAGRAM):   ;
27826      ;
MPRINT(EM_DIAGRAM):   ;
27827      ;
MPRINT(EM_DIAGRAM):   ;
27828      quit;
MPRINT(EM_DIAGRAM):   quit;
27829      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27830      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
27831      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27832      /*; *"; *'; */
27833      ;
MPRINT(EM_DIAGRAM):   ;
27834      run;
MPRINT(EM_DIAGRAM):   run;
27835      quit;
MPRINT(EM_DIAGRAM):   quit;
27836      /* Reset EM Options */
27837      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
27838      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
27839      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
27840      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
27841      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
27842      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
